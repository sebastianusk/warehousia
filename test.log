FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 36 times
Total time:   0.000531
 Self time:   0.000531

count  total (s)   self (s)
   36              0.000349   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
   36              0.000029   endif

FUNCTION  <SNR>23_on_focus_gained()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:77
Called 3 times
Total time:   0.280699
 Self time:   0.000120

count  total (s)   self (s)
    3   0.000125   0.000053   if airline#util#try_focusgained()
    3   0.280567   0.000060     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    3              0.000001   endif

FUNCTION  <SNR>231_cpath()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:136
Called 1 time
Total time:   0.000040
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000017   0.000009   if s:FileIgnoreCase(0)
                                let path = FugitiveVimPath(tolower(a:path))
    1              0.000001   else
    1   0.000015   0.000008     let path = FugitiveVimPath(a:path)
    1              0.000001   endif
    1              0.000003   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  <SNR>258_GetCallbacks()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim:264
Called 1 time
Total time:   0.000491
 Self time:   0.000325

count  total (s)   self (s)
    1              0.000007     if len(a:fixers)
                                    let l:callback_list = a:fixers
    1              0.000007     elseif type(get(b:, 'ale_fixers')) is v:t_list
                                    " Lists can be used for buffer-local variables only
                                    let l:callback_list = b:ale_fixers
    1              0.000001     else
                                    " buffer and global options can use dictionaries mapping filetypes to
                                    " callbacks to run.
    1   0.000035   0.000011         let l:fixers = ale#Var(a:buffer, 'fixers')
    1              0.000007         let l:callback_list = []
    1              0.000002         let l:matched = 0
                            
    2              0.000020         for l:sub_type in split(&filetype, '\.')
    1   0.000045   0.000026             if s:AddSubCallbacks(l:callback_list, get(l:fixers, l:sub_type))
                                            let l:matched = 1
    1              0.000001             endif
    2              0.000002         endfor
                            
                                    " If we couldn't find fixers for a filetype, default to '*' fixers.
    1              0.000001         if !l:matched
    1   0.000039   0.000017             call s:AddSubCallbacks(l:callback_list, get(l:fixers, '*'))
    1              0.000001         endif
    1              0.000001     endif
                            
    1              0.000003     if a:fixing_flag is# 'save_file'
    1   0.000034   0.000011         let l:config = ale#Var(a:buffer, 'fix_on_save_ignore')
                            
    1              0.000003         if !empty(l:config)
                                        call s:IgnoreFixers(l:callback_list, &filetype, l:config)
    1              0.000001         endif
    1              0.000001     endif
                            
    1              0.000004     let l:corrected_list = []
                            
                                " Variables with capital characters are needed, or Vim will complain about
                                " funcref variables.
    3              0.000009     for l:Item in l:callback_list
                                    " Try to capture the names of registered fixer names, so we can use
                                    " them for filename mapping or other purposes later.
    2              0.000005         let l:fixer_name = v:null
                            
    2              0.000008         if type(l:Item) is v:t_string
    2   0.000087   0.000030             let l:Func = ale#fix#registry#GetFunc(l:Item)
                            
    2              0.000006             if !empty(l:Func)
    2              0.000005                 let l:fixer_name = l:Item
    2              0.000005                 let l:Item = l:Func
    2              0.000002             endif
    2              0.000001         endif
                            
    2              0.000002         try
    2   0.000061   0.000040             call add(l:corrected_list, [   l:fixer_name,   ale#util#GetFunction(l:Item)])
                                    catch /E475/
                                        " Rethrow exceptions for failing to get a function so we can print
                                        " a friendly message about it.
                                        throw 'BADNAME ' . v:exception
    2              0.000006         endtry
    3              0.000004     endfor
                            
    1              0.000002     return l:corrected_list

FUNCTION  <SNR>81_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:197
Called 10 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
   10              0.000047   if exists('w:paren_hl_on') && w:paren_hl_on
    2              0.000008     silent! call matchdelete(3)
    2              0.000005     let w:paren_hl_on = 0
   10              0.000006   endif

FUNCTION  <SNR>101_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 84 times
Total time:   0.058955
 Self time:   0.003058

count  total (s)   self (s)
   84   0.001902   0.000860   call airline#util#ignore_next_focusgain()
   84   0.001542   0.000663   if airline#util#has_fugitive()
   84   0.054752   0.000775     call s:config_fugitive_branch()
                              elseif airline#util#has_gina()
                                call s:config_gina_branch()
                              else
                                let s:vcs_config['git'].branch = ''
                                return
   84              0.000045   endif

FUNCTION  <SNR>23_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:216
Called 3 times
Total time:   0.280507
 Self time:   0.003605

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    3              0.000023   let fast=!empty(get(a:000, 0, 0))
    3              0.000013   if !exists("#airline")
                                " disabled
                                return
    3              0.000005   endif
    3   0.000427   0.000034   call airline#util#doautocmd('AirlineBeforeRefresh')
    3   0.030727   0.000045   call airline#highlighter#reset_hlcache()
    3              0.000027   if !fast
                                call airline#load_theme()
    3              0.000004   endif
    3   0.249191   0.003384   call airline#update_statusline()
    3   0.000062   0.000040   call airline#update_tabline()

FUNCTION  airline#extensions#ale#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:116
Called 84 times
Total time:   0.022244
 Self time:   0.001140

count  total (s)   self (s)
   84   0.022179   0.001076   return airline#extensions#ale#get('error')

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 17 times
Total time:   0.000486
 Self time:   0.000210

count  total (s)   self (s)
   17   0.000343   0.000132   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   17   0.000132   0.000067   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>237_reset_summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 4 times
Total time:   0.000083
 Self time:   0.000033

count  total (s)   self (s)
    4   0.000082   0.000031   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#linter#Get()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:367
Called 2 times
Total time:   0.001004
 Self time:   0.000507

count  total (s)   self (s)
    2              0.000009     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    4              0.000030     for l:original_filetype in split(a:original_filetypes, '\.')
    2   0.000211   0.000029         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    2   0.000095   0.000025         let l:linter_names = s:GetLinterNames(l:original_filetype)
    2   0.000286   0.000041         let l:all_linters = ale#linter#GetAll(l:filetype)
    2              0.000005         let l:filetype_linters = []
                            
    2              0.000012         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    2              0.000004             let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
    2              0.000004         endif
                            
    2              0.000008         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    4              0.000005     endfor
                            
    2              0.000005     let l:name_list = []
    2              0.000004     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   16              0.000028     for l:linter in reverse(l:possibly_duplicated_linters)
   14              0.000050         if index(l:name_list, l:linter.name) < 0
   14              0.000042             call add(l:name_list, l:linter.name)
   14              0.000040             call add(l:combined_linters, l:linter)
   14              0.000010         endif
   16              0.000013     endfor
                            
    2              0.000008     return reverse(l:combined_linters)

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:14
Called 84 times
Total time:   0.003645
 Self time:   0.000881

count  total (s)   self (s)
   84   0.003595   0.000832   return airline#extensions#coc#get('error')

FUNCTION  <SNR>63_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:223
Called 84 times
Total time:   0.001127
 Self time:   0.001127

count  total (s)   self (s)
   84              0.000203   let dir = a:path
   84              0.000455   if dir =~# '/\.git$'
   84              0.000402     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:717
Called 118 times
Total time:   0.002285
 Self time:   0.002285

count  total (s)   self (s)
  118              0.001694   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
  118              0.000129   endif

FUNCTION  <SNR>65_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 22 times
Total time:   0.001169
 Self time:   0.001169

count  total (s)   self (s)
   22              0.000755   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   22              0.000309   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   22              0.000066   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:216
Called 91 times
Total time:   4.624055
 Self time:   0.015420

count  total (s)   self (s)
   91              0.000417   if !has_key(s:contexts, a:winnr)
                                return ''
   91              0.000088   endif
   91              0.000400   let context = s:contexts[a:winnr]
                            
   91              0.000339   if get(w:, 'airline_active', 1)
   84              0.000295     let m = mode(1)
   84              0.000198     if m ==# "i"
                                  let mode = ['insert']
   84              0.000185     elseif m[0] ==# "i"
                                  let mode = ['insert']
   84              0.000094     elseif m ==# "Rv"
                                  let mode =['replace']
   84              0.000103     elseif m[0] ==# "R"
                                  let mode = ['replace']
   84              0.000966     elseif m[0] =~# '\v(v|V||s|S|)'
                                  let mode = ['visual']
   84              0.000092     elseif m ==# "t"
                                  let mode = ['terminal']
   84              0.000099     elseif m[0] ==# "c"
    2              0.000006       let mode = ['commandline']
   82              0.000119     elseif m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let mode = ['normal']
   82              0.000148     elseif m[0:1] ==# 'ni'
                                  let mode = ['insert']
                                  let m = 'ni'
   82              0.000055     else
   82              0.000433       let mode = ['normal']
   84              0.000063     endif
   84              0.000451     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
   84              0.000049     endif
   84              0.000726     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], m) == -1
   84              0.000163       let m = m[0]
   84              0.000050     endif
   84              0.000456     let w:airline_current_mode = get(g:airline_mode_map, m, m)
    7              0.000005   else
    7              0.000020     let mode = ['inactive']
    7              0.000034     let w:airline_current_mode = get(g:airline_mode_map, '__')
   91              0.000059   endif
                            
   91              0.000377   if g:airline_detect_modified && &modified
   73              0.000297     call add(mode, 'modified')
   91              0.000056   endif
                            
   91              0.000195   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
   91              0.000051   endif
                            
   91              0.001108   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
   91              0.000055   endif
                            
   91              0.000202   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
   91              0.000042   endif
                            
   91              0.000176   if &readonly || ! &modifiable
                                call add(mode, 'readonly')
   91              0.000042   endif
                            
   91              0.000445   let mode_string = join(mode)
   91              0.000446   if get(w:, 'airline_lastmode', '') != mode_string
    8   0.001451   0.000126     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    8   4.606845   0.000240     call airline#highlighter#highlight(mode, string(context.bufnr))
    8   0.002004   0.001299     call airline#util#doautocmd('AirlineModeChanged')
    8              0.000023     let w:airline_lastmode = mode_string
   91              0.000049   endif
                            
   91              0.000116   return ''

FUNCTION  ale#handlers#eslint#HandleJSON()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim:274
Called 1 time
Total time:   0.000291
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000291   0.000009     return s:HandleESLintOutput(a:buffer, a:lines, 'json')

FUNCTION  <SNR>117_reset_tick()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:166
Called 68 times
Total time:   0.002295
 Self time:   0.000645

count  total (s)   self (s)
   68   0.002251   0.000600   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  <SNR>102_sh_autocmd_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:46
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000008   if exists('#airline')
    3              0.000014     unlet! b:fugitive_name
    3              0.000002   endif

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:190
Called 62 times
Total time:   0.001034
 Self time:   0.001034

count  total (s)   self (s)
   62              0.000304   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
    1              0.000001     return
   61              0.000334   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
   61              0.000032   endif

FUNCTION  ale#command#CdString()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:173
Called 2 times
Total time:   0.000109
 Self time:   0.000079

count  total (s)   self (s)
    2              0.000029     let l:match = matchstrpos(a:directory, s:path_format_regex)
                                " Do not escape the directory here if it's a valid format string.
                                " This allows us to use sequences like %s:h, %s:h:h, etc.
    2   0.000058   0.000028     let l:directory = l:match[1:] == [0, len(a:directory)]   ? a:directory   : ale#Escape(a:directory)
                            
    2              0.000007     if has('win32')
                                    return 'cd /d ' . l:directory . ' && '
    2              0.000001     endif
                            
    2              0.000005     return 'cd ' . l:directory . ' && '

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:250
Called 2 times
Total time:   0.000132
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000009     if exists('*sign_getplaced')
    2   0.000122   0.000024         return ale#sign#ParseSignsWithGetPlaced(a:buffer)
                                else
                                    let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
                                    return ale#sign#ParseSigns(l:line_list)
                                endif

FUNCTION  ale#highlight#nvim_buf_add_highlight()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:36
Called 10 times
Total time:   0.000743
 Self time:   0.000743

count  total (s)   self (s)
                                " Ignore all errors for adding highlights.
   10              0.000009     try
   10              0.000694         call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
                                catch
   10              0.000009     endtry

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:10
Called 84 times
Total time:   0.003937
 Self time:   0.000904

count  total (s)   self (s)
   84   0.003893   0.000859   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 168 times
Total time:   0.009556
 Self time:   0.009556

count  total (s)   self (s)
  168              0.009104   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
  168              0.000287     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:143
Called 108 times
Total time:   0.001132
 Self time:   0.001132

count  total (s)   self (s)
  108              0.000356   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
  108              0.000061   endif
  108              0.000212   return s:has_fugitive

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 40 times
Total time:   0.026133
 Self time:   0.003507

count  total (s)   self (s)
   40              0.000123   let winnr = a:context.winnr
   40              0.000124   let active = a:context.active
                            
   40   0.000725   0.000469   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    4   0.001561   0.000049     call s:build_sections(a:builder, a:context, s:layout[0])
   36              0.000031   else
   36   0.002438   0.000363     let text = s:get_section(winnr, 'c')
   36              0.000068     if empty(text)
                                  let text = ' %f%m '
   36              0.000022     endif
   36   0.000592   0.000358     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   40              0.000028   endif
                            
   40   0.002876   0.000651   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   40   0.000456   0.000311   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   40   0.016623   0.000445     call s:build_sections(a:builder, a:context, s:layout[1])
   40              0.000026   endif
                            
   40              0.000050   return 1

FUNCTION  <SNR>225_AddHintsForTypeScriptParsingErrors()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim:81
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003     for l:item in a:output
                                    let l:item.text = substitute(   l:item.text,   '^\(Parsing error\)',   '\1 (You may need configure typescript-eslint-parser)',   '',)
    1              0.000001     endfor

FUNCTION  ale#job#Start()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:215
Called 2 times
Total time:   0.010187
 Self time:   0.010160

count  total (s)   self (s)
    2   0.000049   0.000022     call ale#job#ValidateArguments(a:command, a:options)
                            
    2              0.000009     let l:job_info = copy(a:options)
    2              0.000004     let l:job_options = {}
                            
    2              0.000005     if has('nvim')
    2              0.000004         if has_key(a:options, 'out_cb')
    2              0.000010             let l:job_options.on_stdout = function('s:NeoVimCallback')
    2              0.000003             let l:job_info.out_cb_line = ''
    2              0.000001         endif
                            
    2              0.000003         if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
    2              0.000001         endif
                            
    2              0.000003         if has_key(a:options, 'exit_cb')
    2              0.000007             let l:job_options.on_exit = function('s:NeoVimCallback')
    2              0.000001         endif
                            
    2              0.009886         let l:job_info.job = jobstart(a:command, l:job_options)
    2              0.000022         let l:job_id = l:job_info.job
                                else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
    2              0.000002     endif
                            
    2              0.000007     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    2              0.000023         let s:job_map[l:job_id] = l:job_info
    2              0.000002     endif
                            
    2              0.000009     return l:job_id

FUNCTION  ale#command#SetCwd()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:34
Called 3 times
Total time:   0.000072
 Self time:   0.000041

count  total (s)   self (s)
    3   0.000057   0.000026     call ale#command#InitData(a:buffer)
    3              0.000013     let s:buffer_data[a:buffer].cwd = a:cwd

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 91 times
Total time:   0.002382
 Self time:   0.001259

count  total (s)   self (s)
   91   0.002301   0.001178   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 4 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    4              0.000042   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    4              0.000002   endif

FUNCTION  ale#util#HasBuflineApi()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:498
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005     return exists('*deletebufline') && exists('*setbufline')

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 84 times
Total time:   0.000635
 Self time:   0.000635

count  total (s)   self (s)
   84              0.000269   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   84              0.000044   endif
   84              0.000104   return ''

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 4 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    4              0.000029   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    4              0.000002   endif

FUNCTION  ale#handlers#tslint#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/tslint.vim:9
Called 2 times
Total time:   0.001065
 Self time:   0.000046

count  total (s)   self (s)
    2   0.001061   0.000042     return ale#path#FindExecutable(a:buffer, 'typescript_tslint', [   'node_modules/.bin/tslint',])

FUNCTION  coc#rpc#request()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:89
Called 2 times
Total time:   0.004166
 Self time:   0.000069

count  total (s)   self (s)
    2   0.000051   0.000022   if !coc#rpc#ready()
                                return ''
    2              0.000001   endif
    2   0.004108   0.000041   return s:client['request'](a:method, a:args)

FUNCTION  coc#float#get_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1198
Called 7 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    7              0.000063   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
    7              0.000009   endfor
    7              0.000008   return 0

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 5 times
Total time:   0.024454
 Self time:   0.000543

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    5   0.001463   0.000040   if gitgutter#utility#is_active(a:bufnr)
                            
    5              0.000028     if has('patch-7.4.1559')
    5              0.000046       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    5              0.000003     endif
    5   0.000329   0.000049     let how = s:setup_path(a:bufnr, l:Callback)
    5              0.000016     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
    5              0.000003     endif
                            
    5   0.000054   0.000024     if a:force || s:has_fresh_changes(a:bufnr)
                            
    4              0.000005       let diff = 'NOT SET'
    4              0.000004       try
    4   0.022311   0.000131         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    4              0.000005       endtry
                            
    4              0.000017       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    4              0.000003       endif
                            
    5              0.000003     endif
    5              0.000002   endif

FUNCTION  <SNR>130_GetAliasedFiletype()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:294
Called 2 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    2              0.000021     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    2              0.000016     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
    2              0.000002     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    6              0.000023     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    6              0.000023         if has_key(l:dict, a:original_filetype)
    2              0.000008             return l:dict[a:original_filetype]
    4              0.000002         endif
    4              0.000003     endfor
                            
                                return a:original_filetype

FUNCTION  <SNR>65_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 4 times
Total time:   0.000222
 Self time:   0.000034

count  total (s)   self (s)
    4   0.000219   0.000031   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>103_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:68
Called 140 times
Total time:   0.016930
 Self time:   0.002247

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
  140              0.000510   if exists("*ale#statusline#FirstProblem")
  140   0.016269   0.001586     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  <SNR>247_UpdateLineNumbers()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:282
Called 2 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    2              0.000005     let l:line_map = {}
    2              0.000004     let l:line_numbers_changed = 0
                            
    3              0.000012     for [l:line, l:sign_id, l:name] in a:current_sign_list
    1              0.000005         let l:line_map[l:sign_id] = l:line
    3              0.000003     endfor
                            
    2              0.000005     for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
    2              0.000002     endfor
                            
                                " When the line numbers change, sort the list again
    2              0.000003     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
    2              0.000001     endif

FUNCTION  <SNR>238_process_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:293
Called 6 times
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
    6              0.000007   let offset = 0
   38              0.000045   while offset < a:to_count
   32              0.000040     let line_number = a:to_line + offset
   32              0.000070     call add(a:modifications, [line_number, 'added'])
   32              0.000027     let offset += 1
   38              0.000017   endwhile

FUNCTION  <SNR>238_is_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000006   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:51
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
    1              0.000006     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
    1              0.000000     endif
                            
                                " When entering a buffer, we are no longer quitting it.
    1              0.000005     call setbufvar(a:buffer, 'ale_quitting', 0)
    1              0.000004     let l:filetype = getbufvar(a:buffer, '&filetype')
    1              0.000005     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
    1              0.000002     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
    1              0.000000     endif

FUNCTION  <SNR>93_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:194
Called 40 times
Total time:   0.341461
 Self time:   0.003525

count  total (s)   self (s)
   40   0.001992   0.000428   let builder = airline#builder#new(a:context)
   40   0.040485   0.000814   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   40              0.000056   if err == 1
   40   0.297295   0.000593     let a:context.line = builder.build()
   40              0.000549     let s:contexts[a:context.winnr] = a:context
   40              0.000227     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
   40              0.000730     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
   40              0.000032   endif

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 5 times
Total time:   0.000220
 Self time:   0.000070

count  total (s)   self (s)
    5   0.000214   0.000065   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>67_VimNavigate()
    Defined: ~/.vim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim:10
Called 1 time
Total time:   0.113232
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000002   try
    1   0.113223   0.000028     execute 'wincmd ' . a:direction
                              catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
    1              0.000001   endtry

FUNCTION  ale#Var()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:180
Called 55 times
Total time:   0.001104
 Self time:   0.001104

count  total (s)   self (s)
   55              0.000238     let l:full_name = 'ale_' . a:variable_name
   55              0.000417     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   55              0.000358     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  FugitiveVimPath()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:360
Called 85 times
Total time:   0.000817
 Self time:   0.000817

count  total (s)   self (s)
   85              0.000366   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
   85              0.000073   else
   85              0.000122     return a:path
                              endif

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 6 times
Total time:   0.000254
 Self time:   0.000082

count  total (s)   self (s)
    6   0.000134   0.000032   let summary = gitgutter#hunk#summary(a:bufnr)
    6              0.000010   let summary[0] += a:count
    6   0.000108   0.000037   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 4 times
Total time:   0.000632
 Self time:   0.000089

count  total (s)   self (s)
    4   0.000311   0.000053   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    4   0.000316   0.000031   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:144
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000008     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
    2              0.000001     endif

FUNCTION  <SNR>242_syn_name()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim:32
Called 7 times
Total time:   0.001681
 Self time:   0.001681

count  total (s)   self (s)
    7              0.001639   let syn_id = get(synstack(a:lnum, a:cnum), -1)
    7              0.000032   return synIDattr(syn_id, "name")

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:176
Called 11 times
Total time:   0.001098
 Self time:   0.000338

count  total (s)   self (s)
   11              0.000070   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
   11              0.000007   endif
   11   0.000987   0.000227   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:15
Called 91 times
Total time:   0.006605
 Self time:   0.006096

count  total (s)   self (s)
   91              0.000445   if !exists('b:fugitive_name')
    3              0.000008     let b:fugitive_name = ''
    3              0.000002     try
    3              0.000019       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    3              0.000011       elseif exists('b:git_dir') && exists('*fugitive#repo')
    3              0.000007         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
    3              0.000002         endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    3              0.000001       endif
                                catch
    3              0.000002     endtry
   91              0.000048   endif
                            
   91   0.001292   0.000784   let fmod = s:ModifierFlags()
   91              0.000203   if empty(b:fugitive_name)
   91              0.000298     if empty(bufname('%'))
                                  return &buftype ==# 'nofile' ? '[Scratch]' : '[No Name]'
   91              0.000053     endif
   91              0.001400     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:49
Called 1 time
Total time:   0.000057
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000052   0.000008     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    1              0.000002     let l:obj.exit_code = a:exit_code
    1              0.000001     let l:obj.status = 'finished'

FUNCTION  ale#util#Writefile()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:431
Called 2 times
Total time:   0.000217
 Self time:   0.000217

count  total (s)   self (s)
    2              0.000018     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
    2              0.000041     let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
    2              0.000152     call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks

FUNCTION  <SNR>62_request()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:154
Called 2 times
Total time:   0.004067
 Self time:   0.004047

count  total (s)   self (s)
    2   0.000049   0.000028   let channel = coc#client#get_channel(self)
    2              0.000010   if empty(channel) | return '' | endif
    2              0.000003   try
    2              0.000003     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
    2              0.000001     else
    2              0.003843       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
    2              0.000004   endtry

FUNCTION  <SNR>101_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:180
Called 84 times
Total time:   0.071759
 Self time:   0.006177

count  total (s)   self (s)
  252              0.001112   for vcs in keys(s:vcs_config)
  168   0.067820   0.002238     call {s:vcs_config[vcs].update_branch}()
  168              0.000912     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  168              0.000098     endif
  252              0.000244   endfor

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:205
Called 4 times
Total time:   0.000463
 Self time:   0.000210

count  total (s)   self (s)
    4              0.000006   let hunks = []
   14              0.000034   for line in split(a:diff, '\n')
   10   0.000336   0.000082     let hunk_info = gitgutter#diff#parse_hunk(line)
   10              0.000016     if len(hunk_info) == 4
   10              0.000018       call add(hunks, hunk_info)
   10              0.000015     endif
   14              0.000009   endfor
    4              0.000005   return hunks

FUNCTION  ale#fix#registry#GetFunc()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix/registry.vim:535
Called 2 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                                " Use the exact name, or an alias.
    2              0.000020     let l:resolved_name = !has_key(s:entries, a:name)   ? get(s:aliases, a:name, a:name)   : a:name
                            
    2              0.000032     return get(s:entries, l:resolved_name, {'function': ''}).function

FUNCTION  <SNR>223_RunJob()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:401
Called 2 times
Total time:   0.013275
 Self time:   0.000347

count  total (s)   self (s)
    2   0.000027   0.000016     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
    2              0.000001     endif
                            
    2              0.000003     let l:command = a:command
                            
    2              0.000003     if empty(l:command)
                                    return 0
    2              0.000001     endif
                            
    2              0.000004     let l:cwd = a:options.cwd
    2              0.000004     let l:executable = a:options.executable
    2              0.000003     let l:buffer = a:options.buffer
    2              0.000003     let l:linter = a:options.linter
    2              0.000004     let l:output_stream = a:options.output_stream
    2              0.000006     let l:read_buffer = a:options.read_buffer && !a:options.lint_file
    2              0.000009     let l:info = g:ale_buffer_info[l:buffer]
                            
    2              0.000035     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,}])
    2   0.012754   0.000098     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'cwd': l:cwd,   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': 1,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),})
                            
                                " Only proceed if the job is being run.
    2              0.000009     if empty(l:result)
                                    return 0
    2              0.000002     endif
                            
    2   0.000129   0.000062     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    2   0.000237   0.000043     silent doautocmd <nomodeline> User ALEJobStarted
                            
    2              0.000007     return 1

FUNCTION  ale#statusline#Count()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:119
Called 140 times
Total time:   0.008210
 Self time:   0.001806

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  140   0.008033   0.001629     return copy(s:GetCounts(a:buffer))

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:43
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>213_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000025   if has('unix')
    4              0.000012     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:101
Called 174 times
Total time:   0.003118
 Self time:   0.003118

count  total (s)   self (s)
  174              0.001235     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
  174              0.001604     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:28
Called 2 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    2              0.000007     let l:found = 0
                            
    2              0.000017     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
    2              0.000003     endfor
                            
    2              0.000004     if !l:found
    2              0.000009         call add(a:info.active_linter_list, a:linter)
    2              0.000002     endif

FUNCTION  <SNR>65_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 5 times
Total time:   0.000478
 Self time:   0.000103

count  total (s)   self (s)
    5   0.000474   0.000098   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>233_AutoUpdate()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:2791
Called 1 time
Total time:   0.000500
 Self time:   0.000239

count  total (s)   self (s)
    1   0.000034   0.000021     call tagbar#debug#log('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
    1              0.000004     let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    1              0.000004     if exists('s:tagbar_qf_active')
                                    return
    1              0.000003     elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call tagbar#debug#log('Still opening window, stopping processing')
                                    return
    1              0.000001     endif
                            
                                " Get the filetype of the file we're about to process
    1              0.000119     let bufnr = bufnr(a:fname)
    1              0.000008     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    1              0.000003     if ftype ==# 'tagbar'
                                    call tagbar#debug#log('In Tagbar window, stopping processing')
                                    return
    1              0.000001     endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    1              0.000013     let sftype = get(split(ftype, '\.'), 0, '')
    1   0.000029   0.000017     call tagbar#debug#log("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    1   0.000244   0.000015     if !s:IsValidFile(a:fname, sftype)
    1   0.000010   0.000005         call tagbar#debug#log('Not a valid file, stopping processing')
    1              0.000004         let s:nearby_disabled = 1
    1              0.000001         return
                                endif
                            
                                let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
                                if s:known_files.has(a:fname)
                                    let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
                                    if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call tagbar#debug#log('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
                                    else
                                        call tagbar#debug#log('File data seems up to date [' . a:fname . ']')
                                    endif
                                elseif !s:known_files.has(a:fname)
                                    call tagbar#debug#log('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
                                if no_display
                                    return
                                endif
                            
                                let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
                                if empty(fileinfo)
                                    call tagbar#debug#log('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
                                if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(tagbar#state#get_current_file(0)) && a:fname != tagbar#state#get_current_file(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
                                if !empty(fileinfo)
                                    call tagbar#debug#log('Setting current file [' . a:fname . ']')
                                    call tagbar#state#set_current_file(fileinfo)
                                    let s:nearby_disabled = 0
                                endif
                            
                                call s:HighlightTag(0)
                                call s:SetStatusLine()
                                call tagbar#debug#log('AutoUpdate finished successfully')

FUNCTION  airline#extensions#ale#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:77
Called 168 times
Total time:   0.043171
 Self time:   0.014490

count  total (s)   self (s)
  168              0.001042   if !exists(':ALELint')
                                return ''
  168              0.000128   endif
                            
  168              0.000800   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
  168              0.000866   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
  168              0.000531   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
  168              0.000558   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
  168              0.000451   let is_err = a:type ==# 'error'
                            
  168   0.004813   0.001806   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
   28              0.000082     return is_err ? '' : checking_symbol
  140              0.000089   endif
                            
  140              0.000403   let symbol = is_err ? error_symbol : warning_symbol
                            
  140   0.009568   0.001358   let counts = ale#statusline#Count(bufnr(''))
  140              0.000722   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
  140              0.000370     let errors = counts.error + counts.style_error
  140              0.000388     let num = is_err ? errors : counts.total - errors
                              else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
  140              0.000077   endif
                            
  140              0.000220   if show_line_numbers == 1
  140   0.020285   0.002820     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:13
Called 169 times
Total time:   0.009952
 Self time:   0.009739

count  total (s)   self (s)
  169              0.000377   if v:version < 704
                                return ''
  169              0.000712   elseif !a:0 || type(a:1) == type(0) && a:1 < 0
   85              0.000226     if exists('g:fugitive_event')
                                  return g:fugitive_event
   85              0.000068     endif
   85              0.000527     let dir = get(b:, 'git_dir', '')
   85              0.000380     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   85              0.001330     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                  return b:git_dir
   85              0.000059     endif
   85              0.000640     return dir =~# s:bad_git_dir ? '' : dir
   84              0.000210   elseif type(a:1) == type(0)
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
   84              0.000190   elseif type(a:1) == type('')
   84   0.001367   0.001155     return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'git_dir', '')
                              else
                                return ''
                              endif

FUNCTION  ale#handlers#eslint#GetCwd()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim:43
Called 2 times
Total time:   0.001296
 Self time:   0.000118

count  total (s)   self (s)
                                " ESLint 6 loads plugins/configs/parsers from the project root
                                " By default, the project root is simply the CWD of the running process.
                                " https://github.com/eslint/rfcs/blob/master/designs/2018-simplified-package-loading/README.md
                                " https://github.com/dense-analysis/ale/issues/2787
                                "
                                " If eslint is installed in a directory which contains the buffer, assume
                                " it is the ESLint project root.  Otherwise, use nearest node_modules.
                                " Note: If node_modules not present yet, can't load local deps anyway.
    2   0.001154   0.000019     let l:executable = ale#path#FindNearestExecutable(a:buffer, s:executables)
                            
    2              0.000003     if !empty(l:executable)
    2              0.000008         let l:modules_index = strridx(l:executable, 'node_modules')
    2              0.000009         let l:modules_root = l:modules_index > -1 ? l:executable[0:l:modules_index - 2] : ''
                            
    2   0.000069   0.000025         let l:sdks_index = strridx(l:executable, ale#path#Simplify('.yarn/sdks'))
    2              0.000007         let l:sdks_root = l:sdks_index > -1 ? l:executable[0:l:sdks_index - 2] : ''
                                else
                                    let l:modules_dir = ale#path#FindNearestDirectory(a:buffer, 'node_modules')
                                    let l:modules_root = !empty(l:modules_dir) ? fnamemodify(l:modules_dir, ':h:h') : ''
                            
                                    let l:sdks_dir = ale#path#FindNearestDirectory(a:buffer, ale#path#Simplify('.yarn/sdks'))
                                    let l:sdks_root = !empty(l:sdks_dir) ? fnamemodify(l:sdks_dir, ':h:h:h') : ''
    2              0.000001     endif
                            
    2              0.000010     return strlen(l:modules_root) > strlen(l:sdks_root) ? l:modules_root : l:sdks_root

FUNCTION  ale#command#Run()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:333
Called 2 times
Total time:   0.012577
 Self time:   0.000715

count  total (s)   self (s)
    2              0.000008     let l:options = get(a:000, 0, {})
                            
    2              0.000005     if len(a:000) > 1
                                    throw 'Too many arguments!'
    2              0.000001     endif
                            
    2              0.000007     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    2              0.000004     let l:line_list = []
    2              0.000005     let l:cwd = get(l:options, 'cwd', v:null)
                            
    2              0.000004     if l:cwd is v:null
                                    " Default the working directory to whatever it was for the last
                                    " command run in the chain.
                                    let l:cwd = get(get(s:buffer_data, a:buffer, {}), 'cwd', v:null)
    2              0.000001     endif
                            
    2   0.001202   0.000056     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),   l:cwd,   get(l:options, 'filename_mappings', []),)
    2   0.000246   0.000062     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    2              0.000037     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    2              0.000006     if l:output_stream is# 'stdout'
    2              0.000015         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    2              0.000001     endif
                            
    2              0.000003     let l:status = 'failed'
                            
    2              0.000006     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
    2              0.000007     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
    2              0.000001     else
    2   0.010250   0.000063         let l:job_id = ale#job#Start(l:command, l:job_options)
    2              0.000002     endif
                            
    2              0.000003     if l:job_id
    2              0.000010         let l:status = 'started'
    2              0.000017         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    2   0.000111   0.000066         call ale#command#InitData(a:buffer)
    2              0.000016         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    2              0.000002     endif
                            
    2              0.000005     if g:ale_history_enabled
    2   0.000346   0.000047         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    2              0.000002     endif
                            
    2              0.000004     if !l:job_id
                                    return 0
    2              0.000002     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The cwd is kept and used as the default value for the next command in
                                " the chain.
                                "
                                " The original command here is used in tests.
    2              0.000030     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'cwd': l:cwd,   'command': a:command,}
                            
    2              0.000013     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
    2              0.000002     endif
                            
    2              0.000007     return l:result

FUNCTION  <SNR>247_PriorityCmd()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:154
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002     if s:supports_sign_groups
    1              0.000004         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:88
Called 4 times
Total time:   0.000236
 Self time:   0.000036

count  total (s)   self (s)
    4   0.000231   0.000030   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  airline#async#nvim_vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:336
Called 24 times
Total time:   0.012740
 Self time:   0.012384

count  total (s)   self (s)
   24              0.000301   let cmd = a:cfg.cmd . shellescape(a:file)
   24              0.000045   let id = -1
   24   0.001070   0.000715   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
   24              0.000142   if has("nvim")
   24              0.000560     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
   24              0.000110     if has_key(s:untracked_jobs, config.file)
                                  " still running
   22              0.000026       return
    2              0.000002     endif
    2              0.000002     try
    2              0.010321     let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
    2              0.000004     endtry
    2              0.000020     let s:untracked_jobs[a:file] = id
    2              0.000002   endif
                              " vim without job feature or nvim jobstart failed
    2              0.000005   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
    2              0.000001   endif

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:26
Called 36 times
Total time:   0.000835
 Self time:   0.000835

count  total (s)   self (s)
   36              0.000184   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
   36              0.000023   endif

FUNCTION  <SNR>238_process_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:240
Called 10 times
Total time:   0.001323
 Self time:   0.000574

count  total (s)   self (s)
   10              0.000015   let modifications = []
   10              0.000017   let from_line  = a:hunk[0]
   10              0.000014   let from_count = a:hunk[1]
   10              0.000012   let to_line    = a:hunk[2]
   10              0.000014   let to_count   = a:hunk[3]
                            
   10   0.000078   0.000057   if s:is_added(from_count, to_count)
    6   0.000276   0.000041     call s:process_added(modifications, from_count, to_count, to_line)
    6   0.000295   0.000040     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    4   0.000030   0.000021   elseif s:is_removed(from_count, to_count)
    2   0.000028   0.000014     call s:process_removed(modifications, from_count, to_count, to_line)
    2   0.000096   0.000014     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    2   0.000016   0.000010   elseif s:is_modified(from_count, to_count)
    2   0.000053   0.000016     call s:process_modified(modifications, from_count, to_count, to_line)
    2   0.000107   0.000016     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
   10              0.000004   endif
   10              0.000011   return modifications

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 216 times
Total time:   0.003540
 Self time:   0.003540

count  total (s)   self (s)
  216              0.000584   let x = a:i - 1
  256              0.000402   while x >= 0
  216              0.000612     let group = a:sections[x][0]
  216              0.000818     if group != '' && group != '|'
  176              0.000222       return group
   40              0.000024     endif
   40              0.000056     let x = x - 1
   80              0.000073   endwhile
   40              0.000040   return ''

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:289
Called 14 times
Total time:   0.000284
 Self time:   0.000236

count  total (s)   self (s)
   14              0.000018     try
   14   0.000175   0.000127         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
   14              0.000014     endtry
                            
   14              0.000013     return 0

FUNCTION  <SNR>23_init()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:15
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  <SNR>113_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 216 times
Total time:   0.001910
 Self time:   0.001910

count  total (s)   self (s)
  216              0.000421   let start=1
                            
                              " do not check for inactive windows or the tabline
  216              0.000462   if a:self._context.active == 0
  180              0.000190     return 0
   36              0.000118   elseif get(a:self._context, 'tabline', 0)
                                return 0
   36              0.000022   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   36              0.000109   if get(g:, 'airline_skip_empty_sections', 0) == 0
   36              0.000032     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 4 times
Total time:   0.000069
 Self time:   0.000034

count  total (s)   self (s)
    4   0.000068   0.000032   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>224_ExitCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:285
Called 2 times
Total time:   0.003449
 Self time:   0.000119

count  total (s)   self (s)
    2              0.000011     if !has_key(s:buffer_data, a:buffer)
                                    return
    2              0.000001     endif
                            
    2              0.000009     let l:jobs = s:buffer_data[a:buffer].jobs
                            
    2              0.000006     if !has_key(l:jobs, a:data.job_id)
    1              0.000001         return
    1              0.000000     endif
                            
    1              0.000004     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    1              0.000001     if g:ale_history_enabled
    1   0.000066   0.000009         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    1              0.000002         if g:ale_history_log_output && a:data.log_output is 1
    1   0.000051   0.000011             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    1              0.000000         endif
    1              0.000000     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    1              0.000003     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    1   0.003224   0.000018     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    1              0.000002     let l:result = a:data.result
    1              0.000002     let l:result.value = l:value
                            
                                " Set the default cwd for this buffer in this call stack.
    1   0.000031   0.000009     call ale#command#SetCwd(a:buffer, l:result.cwd)
                            
    1              0.000001     try
    1              0.000004         if get(l:result, 'result_callback', v:null) isnot v:null
                                        call call(l:result.result_callback, [l:value])
    1              0.000000         endif
    1              0.000001     finally
    1   0.000011   0.000006         call ale#command#ResetCwd(a:buffer)
    1              0.000001     endtry

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:173
Called 4 times
Total time:   0.278524
 Self time:   0.002475

count  total (s)   self (s)
    4   0.000245   0.000079   if airline#util#stl_disabled(winnr())
                                return
    4              0.000003   endif
   40              0.000087   for nr in a:range
   36   0.002109   0.000493     if airline#util#stl_disabled(nr)
                                  continue
   36              0.000024     endif
   36              0.000158     call setwinvar(nr, 'airline_active', 0)
   36              0.000254     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   36              0.000119     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
   36              0.000024     endif
   36   0.275099   0.000831     call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
   40              0.000048   endfor

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 2 times
Total time:   0.000090
 Self time:   0.000031

count  total (s)   self (s)
    2   0.000048   0.000013   let summary = gitgutter#hunk#summary(a:bufnr)
    2              0.000004   let summary[1] += a:count
    2   0.000037   0.000013   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  ale#Queue()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:123
Called 2 times
Total time:   0.015587
 Self time:   0.000160

count  total (s)   self (s)
    2              0.000003     if a:0 > 2
                                    throw 'too many arguments!'
    2              0.000001     endif
                            
    2              0.000007     let l:buffer = get(a:000, 1, v:null)
                            
    2              0.000004     if l:buffer is v:null
    2              0.000005         let l:buffer = bufnr('')
    2              0.000001     endif
                            
    2              0.000005     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
    2              0.000001     endif
                            
    2   0.000322   0.000016     if ale#ShouldDoNothing(l:buffer)
                                    return
    2              0.000001     endif
                            
                                " Default linting_flag to ''
    2              0.000009     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    2              0.000003     if s:lint_timer != -1
    2              0.000008         call timer_stop(s:lint_timer)
    2              0.000005         let s:lint_timer = -1
    2              0.000001     endif
                            
    2              0.000003     if a:delay > 0
    1              0.000014         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    1              0.000001     else
    1   0.015156   0.000035         call s:Lint(l:buffer, l:should_lint_file, 0)
    2              0.000003     endif

FUNCTION  ale#engine#ignore#GetList()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine/ignore.vim:6
Called 2 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    2              0.000011     if type(a:config) is v:t_list
                                    return a:config
    2              0.000002     endif
                            
    2              0.000007     if type(a:config) is v:t_dict
    2              0.000010         let l:names_to_remove = []
                            
    4              0.000027         for l:part in split(a:filetype , '\.')
    2              0.000017             call extend(l:names_to_remove, get(a:config, l:part, []))
    4              0.000005         endfor
                            
    2              0.000005         return l:names_to_remove
                                endif
                            
                                return []

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:53
Called 10 times
Total time:   0.001582
 Self time:   0.000914

count  total (s)   self (s)
   10              0.000031     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
   10              0.000007     endif
                            
                                " Check for a cached executable() check.
   10              0.000063     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   10              0.000028     if l:result isnot v:null
    2              0.000002         return l:result
    8              0.000005     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    8              0.000410     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    8              0.000041     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
    8              0.000005     endif
                            
    8              0.000019     if g:ale_history_enabled
    8   0.000816   0.000148         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    8              0.000009     endif
                            
    8              0.000017     return l:result

FUNCTION  ale#Escape()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:219
Called 8 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    8              0.000037     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
    8              0.000004     endif
                            
    8              0.000025     return shellescape (a:str)

FUNCTION  <SNR>238_write_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:375
Called 4 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
    4              0.000180   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    4              0.000019   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    4              0.000002   endif
                            
    4              0.000017   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    4              0.000002   endif
                            
    4              0.000008   if getbufvar(a:bufnr, '&endofline')
    4              0.000010     call add(bufcontents, '')
    4              0.000002   endif
                            
    4              0.000010   let fenc = getbufvar(a:bufnr, '&fileencoding')
    4              0.000007   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    4              0.000002   endif
                            
    4              0.000009   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
    4              0.000001   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    4              0.000003   try
    4              0.000196     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    4              0.000004   endtry

FUNCTION  coc#float#nvim_win_enter()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1118
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000004   let kind = getwinvar(a:winid, 'kind', '')
    1              0.000002   if kind == 'buttons' || kind == 'close'
                                if empty(maparg('<LeftRelease>', 'n'))
                                  nnoremap <buffer><silent> <LeftRelease> :call coc#float#nvim_float_click()<CR>
                                endif
    1              0.000000   endif

FUNCTION  airline#async#vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:57
Called 24 times
Total time:   0.013949
 Self time:   0.001209

count  total (s)   self (s)
   24              0.000065   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
   24              0.000022   else
                                " nvim async or vim without job-feature
   24   0.013374   0.000634     noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
   24              0.000021   endif

FUNCTION  <SNR>258_RunJob()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim:132
Called 2 times
Total time:   0.033704
 Self time:   0.000064

count  total (s)   self (s)
    2   0.000034   0.000020     if ale#command#IsDeferred(a:result)
                                    let a:result.result_callback = {x -> s:RunJob(x, a:options)}
                            
                                    return
    2              0.000001     endif
                            
    2              0.000005     let l:buffer = a:options.buffer
    2              0.000006     let l:input = a:options.input
    2              0.000004     let l:fixer_name = a:options.fixer_name
                            
    2              0.000009     if a:result is 0 || type(a:result) is v:t_list
    2              0.000005         if type(a:result) is v:t_list
    2              0.000003             let l:input = a:result
    2              0.000001         endif
                            
    2   0.017518   0.001762         call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index + 1,   'callback_list': a:options.callback_list,})
                            
    2              0.000002         return
                                endif
                            
                                let l:command = get(a:result, 'command', '')
                            
                                if empty(l:command)
                                    " If the command is empty, skip to the next item.
                                    call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index,   'callback_list': a:options.callback_list,})
                            
                                    return
                                endif
                            
                                let l:read_temporary_file = get(a:result, 'read_temporary_file', 0)
                                let l:read_buffer = get(a:result, 'read_buffer', 1)
                                let l:output_stream = get(a:result, 'output_stream', 'stdout')
                                let l:cwd = get(a:result, 'cwd', v:null)
                            
                                if l:read_temporary_file
                                    let l:output_stream = 'none'
                                endif
                            
                                let l:Callback = function('s:HandleExit', [{   'input': l:input,   'callback_index': a:options.callback_index,   'callback_list': a:options.callback_list,   'process_with': get(a:result, 'process_with', v:null),   'read_temporary_file': l:read_temporary_file,}])
                                let l:run_result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': '',   'read_buffer': l:read_buffer,   'input': l:input,   'log_output': 0,   'cwd': l:cwd,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:fixer_name),})
                            
                                if empty(l:run_result)
                                    call s:RunFixer({   'buffer': l:buffer,   'input': l:input,   'callback_index': a:options.callback_index + 1,   'callback_list': a:options.callback_list,})
                                endif

FUNCTION  ale#fix#ApplyFixes()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim:60
Called 1 time
Total time:   0.015677
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000004     let l:data = g:ale_fix_buffer_data[a:buffer]
    1              0.000002     let l:data.output = a:output
    1              0.000021     let l:data.changes_made = l:data.lines_before !=# l:data.output " no-custom-checks
    1              0.000002     let l:data.done = 1
                            
    1   0.000043   0.000011     call ale#command#RemoveManagedFiles(a:buffer)
                            
    1              0.000003     if !bufexists(a:buffer)
                                    " Remove the buffer data when it doesn't exist.
                                    call remove(g:ale_fix_buffer_data, a:buffer)
    1              0.000001     endif
                            
    1              0.000002     if l:data.changes_made && bufexists(a:buffer)
                                    let l:lines = getbufline(a:buffer, 1, '$')
                            
                                    if l:data.lines_before != l:lines
                                        call remove(g:ale_fix_buffer_data, a:buffer)
                            
                                        if !l:data.ignore_file_changed_errors
                                            execute 'echoerr ''The file was changed before fixing finished'''
                                        endif
                            
                                        return
                                    endif
    1              0.000000     endif
                            
                                " We can only change the lines of a buffer which is currently open,
                                " so try and apply the fixes to the current buffer.
    1   0.015579   0.000022     call ale#fix#ApplyQueuedFixes(a:buffer)

FUNCTION  <SNR>99_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 84 times
Total time:   0.005973
 Self time:   0.001695

count  total (s)   self (s)
   84   0.001759   0.000883   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    5              0.000004     return ''
   79              0.000045   endif
   79   0.004010   0.000609   return GitGutterGetHunkSummary()

FUNCTION  ale#highlight#nvim_buf_clear_namespace()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:44
Called 3 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    3              0.000068     call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)

FUNCTION  <SNR>239_highlight_name_for_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 36 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   36              0.000066   if a:text ==# 'added'
   32              0.000025     return 'GitGutterLineAdded'
    4              0.000005   elseif a:text ==# 'removed'
    2              0.000002     return 'GitGutterLineRemoved'
    2              0.000002   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
    2              0.000002   elseif a:text ==# 'modified'
    2              0.000002     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:439
Called 2 times
Total time:   0.001549
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000009     let l:Command = a:linter.command
                            
    2   0.001537   0.000029     return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 4 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    4              0.000008   return s:available

FUNCTION  <SNR>229_NeoVimCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:29
Called 5 times
Total time:   0.004020
 Self time:   0.000340

count  total (s)   self (s)
    5              0.000030     let l:info = s:job_map[a:job]
                            
    5              0.000011     if a:event is# 'stdout'
    3   0.000220   0.000071         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
    2              0.000004     elseif a:event is# 'stderr'
                                    let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
    2              0.000001     else
    2              0.000011         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
    2              0.000001         endif
                            
    2              0.000006         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
    2              0.000001         endif
                            
    2              0.000003         try
    2   0.003569   0.000037             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
    2              0.000002         finally
                                        " Automatically forget about the job after it's done.
    2              0.000006             if has_key(s:job_map, a:job)
    2              0.000010                 call remove(s:job_map, a:job)
    2              0.000001             endif
    2              0.000002         endtry
    5              0.000003     endif

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:216
Called 10 times
Total time:   0.000254
 Self time:   0.000254

count  total (s)   self (s)
   10              0.000101   let matches = matchlist(a:line, s:hunk_re)
   10              0.000024   if len(matches) > 0
   10              0.000023     let from_line  = str2nr(matches[1])
   10              0.000028     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   10              0.000017     let to_line    = str2nr(matches[3])
   10              0.000022     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   10              0.000026     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:199
Called 89 times
Total time:   0.001085
 Self time:   0.001085

count  total (s)   self (s)
   89              0.000662   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
   89              0.000071   endif

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 168 times
Total time:   0.001092
 Self time:   0.001092

count  total (s)   self (s)
  168              0.000992   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 84 times
Total time:   0.000400
 Self time:   0.000400

count  total (s)   self (s)
   84              0.000344   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:207
Called 3 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    3              0.000031   let dt = localtime() - s:focusgained_ignore_time
    3              0.000012   let s:focusgained_ignore_time = 0
    3              0.000010   return dt >= 1

FUNCTION  <SNR>242_syn_contains()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim:37
Called 2 times
Total time:   0.000881
 Self time:   0.000881

count  total (s)   self (s)
    2              0.000821   let stack = synstack(a:lnum, a:cnum)
    2              0.000048   let syn_names = map(stack, 'synIDattr(v:val, "name")')
    2              0.000009   return index(syn_names, a:syn_name) >= 0

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:144
Called 4 times
Total time:   0.346424
 Self time:   0.000490

count  total (s)   self (s)
    4   0.000283   0.000067   if airline#util#stl_disabled(winnr())
                                return
    4              0.000004   endif
    4              0.000083   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    4   0.278581   0.000056   call airline#update_statusline_inactive(range)
                            
    4              0.000015   unlet! w:airline_render_left w:airline_render_right
    4              0.000066   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    4              0.000014   let w:airline_active = 1
    4              0.000032   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    4   0.067322   0.000128   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:83
Called 2 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    2              0.000123     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  <SNR>113_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 176 times
Total time:   0.009582
 Self time:   0.009582

count  total (s)   self (s)
  176              0.000404   if a:self._context.active
                                " active window
   32              0.000065     let contents = []
   32              0.000327     let content_parts = split(a:contents, '__accent')
   96              0.000187     for cpart in content_parts
   64              0.000568       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   64              0.000212       call add(contents, cpart)
   96              0.000102     endfor
   32              0.000167     let line = join(contents, a:group)
   32              0.000291     let line = substitute(line, '__restore__', a:group, 'g')
  144              0.000096   else
                                " inactive window
  144              0.002437     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
  144              0.001160     let line = substitute(line, '%#__restore__#', '', 'g')
  176              0.000127   endif
  176              0.000252   return line

FUNCTION  <SNR>238_process_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:302
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000002   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
    2              0.000001   else
    2              0.000006     call add(a:modifications, [a:to_line, 'removed'])
    2              0.000001   endif

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 4 times
Total time:   0.022179
 Self time:   0.000870

count  total (s)   self (s)
    4   0.000123   0.000025   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
    4              0.000002   endif
                            
    4   0.000099   0.000025   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    4              0.000002   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    4              0.000004   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    4              0.000013   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    4              0.000014   let s:counter = (s:counter + 1) % 20
    4              0.000012   let buff_file .= '.'.s:counter
                            
    4   0.000263   0.000027   let extension = gitgutter#utility#extension(a:bufnr)
    4              0.000007   if !empty(extension)
    4              0.000009     let buff_file .= '.'.extension
    4              0.000002   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    4   0.000620   0.000067   call s:write_buffer(a:bufnr, buff_file)
                            
    4              0.000007   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    4              0.000014     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    4              0.000009     let from_file .= '.'.s:counter
                            
    4              0.000007     if !empty(extension)
    4              0.000007       let from_file .= '.'.extension
    4              0.000002     endif
                            
                                " Write file from index to temporary file.
    4   0.000438   0.000086     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    4              0.000030     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    4              0.000002   endif
                            
                              " Call git-diff.
    4              0.000031   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    4              0.000004   if s:c_flag
    4              0.000008     let cmd .= ' -c "diff.autorefreshindex=0"'
    4              0.000009     let cmd .= ' -c "diff.noprefix=false"'
    4              0.000007     let cmd .= ' -c "core.safecrlf=false"'
    4              0.000002   endif
    4              0.000020   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    4              0.000010   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    4   0.000153   0.000036     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    4              0.000002   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    4              0.000010   let cmd .= ' || exit 0'
                            
    4              0.000005   let cmd .= ')'
                            
    4   0.000662   0.000030   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    4   0.000047   0.000032   if g:gitgutter_async && gitgutter#async#available()
    4   0.019398   0.000164     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    4              0.000014     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  ale#events#SaveEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:25
Called 1 time
Total time:   0.020062
 Self time:   0.000119

count  total (s)   self (s)
    1   0.000058   0.000023     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    1              0.000002     if l:should_lint
    1              0.000009         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    1              0.000002     endif
                            
    1   0.000060   0.000028     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
    1   0.019915   0.000037         let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
    1              0.000004         let l:should_lint = l:should_lint && !l:will_fix
    1              0.000001     endif
                            
    1              0.000003     if l:should_lint && !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, 'lint_file', a:buffer)
    1              0.000001     endif

FUNCTION  <SNR>59_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:245
Called 68 times
Total time:   0.006951
 Self time:   0.000761

count  total (s)   self (s)
   68              0.000127   if !g:coc_workspace_initialized
                                return
   68              0.000036   endif
   68   0.006673   0.000484   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>248_FixList()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:60
Called 2 times
Total time:   0.000095
 Self time:   0.000062

count  total (s)   self (s)
    2   0.000049   0.000016     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    2              0.000007     let l:new_list = []
                            
    2              0.000006     for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
    2              0.000002     endfor
                            
    2              0.000003     return l:new_list

FUNCTION  <SNR>101_format_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:77
Called 5 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    5              0.000007     return a:name

FUNCTION  <SNR>113_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 48 times
Total time:   0.107013
 Self time:   0.002395

count  total (s)   self (s)
   48              0.000092   let line = ''
   48              0.000303   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   48              0.000033   else
   48   0.105289   0.000671     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   48              0.000300     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   48              0.000263     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   48              0.000124     let line .= '%#'.a:group.'#'
   48              0.000034   endif
   48              0.000070   return line

FUNCTION  <SNR>23_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:83
Called 7 times
Total time:   0.000308
 Self time:   0.000229

count  total (s)   self (s)
    7              0.000094   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
    7              0.000009   endif
    7   0.000163   0.000084   call airline#update_tabline()

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 3212 times
Total time:   1.372320
 Self time:   0.311118

count  total (s)   self (s)
 3212              0.005878     if pumvisible()
                                  return
 3212              0.001597     endif
 3212              0.005086     let colors = a:colors
 3212              0.006770     if len(colors) == 4
 2922              0.007186       call add(colors, '')
 3212              0.001558     endif
                                " colors should always be string values
 3212              0.059058     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
 3212              0.004020     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
 3212              0.001697     endif
 3212   0.903333   0.031221     let old_hi = airline#highlighter#get_highlight(a:group)
 3212              0.026251     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
 3212   0.102638   0.024745     let colors = s:CheckDefined(colors)
 3212   0.140592   0.029395     if old_hi != new_hi || !s:hl_group_exists(a:group)
                                  let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
                                  try
                                    exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
                                  endtry
                                  if has_key(s:hl_groups, a:group)
                                    let s:hl_groups[a:group] = colors
                                  endif
 3212              0.001518     endif

FUNCTION  <SNR>223_RunLinters()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:638
Called 2 times
Total time:   0.028214
 Self time:   0.000635

count  total (s)   self (s)
    2   0.000392   0.000033     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
    2   0.000171   0.000039     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    2   0.000082   0.000029     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    2   0.000051   0.000030     silent doautocmd <nomodeline> User ALELintPre
                            
   12              0.000067     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
   10              0.000029         if !l:lint_file || a:should_lint_file
   10   0.027235   0.000221             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
    2              0.000009                 let l:can_clear_results = 0
   10              0.000011             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
   10              0.000008         endif
   12              0.000025     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    2              0.000003     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
    2              0.000004     elseif a:new_buffer
                                    call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
    2              0.000001     endif

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 84 times
Total time:   0.016360
 Self time:   0.012538

count  total (s)   self (s)
   84              0.000439   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   84              0.000860   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   84              0.000050   endif
   84              0.000969   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   84              0.000390   if !exists('b:airline_whitespace_check')
    1              0.000007     let b:airline_whitespace_check = ''
    1              0.000008     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000002     let trailing = 0
    1              0.000002     let check = 'trailing'
    1              0.000019     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000002       try
    1              0.000005         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000249         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    1              0.000002       endtry
    1              0.000001     endif
                            
    1              0.000002     let mixed = 0
    1              0.000002     let check = 'indent'
    1              0.000020     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000631   0.000029       let mixed = s:check_mixed_indent()
    1              0.000005     endif
                            
    1              0.000004     let mixed_file = ''
    1              0.000002     let check = 'mixed-indent-file'
    1              0.000030     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000162   0.000050       let mixed_file = s:check_mixed_indent_file()
    1              0.000001     endif
                            
    1              0.000002     let long = 0
    1              0.000004     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    1              0.000001     endif
                            
    1              0.000002     let conflicts = 0
    1              0.000003     if index(checks, 'conflicts') > -1
    1   0.000200   0.000022       let conflicts = s:conflict_marker()
    1              0.000002     endif
                            
    1              0.000009     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
    1              0.000001     endif
   84              0.000053   endif
   84   0.003847   0.000918   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>101_sh_autocmd_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:353
Called 3 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000012   if exists('#airline')
    3              0.000027     unlet! b:airline_head b:airline_do_mq_check
    3              0.000002   endif

FUNCTION  <SNR>129_LoadArgCount()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:353
Called 2 times
Total time:   0.000653
 Self time:   0.000653

count  total (s)   self (s)
    2              0.000004     try
    2              0.000523         let l:output = execute('function a:function')
                                catch /E123/
                                    return 0
    2              0.000003     endtry
                            
    2              0.000072     let l:match = matchstr(split(l:output, "\n")[0], '\v\([^)]+\)')[1:-2]
    2              0.000030     let l:arg_list = filter(split(l:match, ', '), 'v:val isnot# ''...''')
                            
    2              0.000006     return len(l:arg_list)

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:53
Called 4 times
Total time:   0.000124
 Self time:   0.000064

count  total (s)   self (s)
    4   0.000103   0.000043   call <sid>check_defined_section(a:name)
    4              0.000018   let w:airline_section_{a:name} .= a:value

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:210
Called 84 times
Total time:   0.007548
 Self time:   0.001338

count  total (s)   self (s)
   84   0.007501   0.001292   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 84 times
Total time:   0.004537
 Self time:   0.001263

count  total (s)   self (s)
   84   0.004454   0.001180   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>223_RunIfExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:527
Called 10 times
Total time:   0.018838
 Self time:   0.000913

count  total (s)   self (s)
   10   0.000218   0.000103     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
   10              0.000008     endif
                            
   10   0.001704   0.000121     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    2              0.000005         let l:job_type = a:lint_file ? 'file_linter' : 'linter'
    2              0.000013         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
    2   0.001354   0.000017         let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
    2              0.000004         if l:cwd isnot v:null
    2   0.000077   0.000027             call ale#command#SetCwd(a:buffer, l:cwd)
    2              0.000001         endif
                            
    2   0.001569   0.000019         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
    2              0.000004         if l:cwd isnot v:null
    2   0.000034   0.000018             call ale#command#ResetCwd(a:buffer)
    2              0.000001         endif
                            
    2              0.000024         let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
    2   0.013349   0.000074         return s:RunJob(l:command, l:options)
    8              0.000007     endif
                            
    8              0.000010     return 0

FUNCTION  ale#handlers#xo#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/xo.vim:9
Called 2 times
Total time:   0.001738
 Self time:   0.000089

count  total (s)   self (s)
    2   0.000117   0.000039     let l:type = ale#handlers#xo#GetType(a:buffer)
                            
    2   0.001612   0.000041     return ale#path#FindExecutable(a:buffer, l:type . '_xo', [   'node_modules/xo/cli.js',   'node_modules/.bin/xo',])

FUNCTION  fugitive#ReloadStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3369
Called 3 times
Total time:   0.000325
 Self time:   0.000109

count  total (s)   self (s)
    3   0.000227   0.000033   call s:ExpireStatus(a:0 ? a:1 : -1)
    3              0.000006   if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
    3              0.000002   else
    3   0.000045   0.000024     call s:ReloadWinStatus()
    3              0.000002     return ''
                              endif
                              exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                              return ''

FUNCTION  <SNR>98_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 3212 times
Total time:   0.111197
 Self time:   0.111197

count  total (s)   self (s)
 3212              0.048383     if !hlexists(a:group)
                                  return 0
 3212              0.048540     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
 3212              0.001871     endif
 3212              0.002440     return 1

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:205
Called 2 times
Total time:   0.001121
 Self time:   0.000108

count  total (s)   self (s)
    2              0.000025     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    2              0.000025     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
    2   0.000045   0.000017     let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                            
    2              0.000004     if !empty(l:exclude_list)
                                    call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
    2              0.000001     endif
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    2   0.001007   0.000023     call ale#highlight#UpdateHighlights()

FUNCTION  <SNR>233_GetNearbyTag()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:3137
Called 11 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
   11              0.000020     if s:nearby_disabled
   11              0.000034         return {}
                                endif
                            
                                let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
                                if empty(fileinfo)
                                    return {}
                                endif
                            
                                let typeinfo = fileinfo.typeinfo
                                if a:0 > 0
                                    let curline = a:1
                                else
                                    let curline = line('.')
                                endif
                                let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
                                for line in range(curline, 1, -1)
                                    if has_key(fileinfo.fline, line)
                                        let curtag = fileinfo.fline[line]
                                        if a:request ==# 'nearest-stl' && typeinfo.getKind(curtag.fields.kind).stl
                                            let tag = curtag
                                            break
                                        elseif a:request ==# 'scoped-stl' && typeinfo.getKind(curtag.fields.kind).stl && curtag.fields.line <= curline && curline <= curtag.fields.end
                                            let tag = curtag
                                            break
                                        elseif a:request ==# 'nearest' || line == curline
                                            let tag = curtag
                                            break
                                        endif
                                    endif
                                endfor
                            
                                return tag

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:50
Called 2 times
Total time:   0.000051
 Self time:   0.000033

count  total (s)   self (s)
    2   0.000031   0.000013     call ale#command#InitData(a:buffer)
    2              0.000014     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 4 times
Total time:   0.000190
 Self time:   0.000067

count  total (s)   self (s)
    4   0.000186   0.000062   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 84 times
Total time:   0.002693
 Self time:   0.002693

count  total (s)   self (s)
   84              0.001243   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   84              0.000221   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   84              0.000052   endif
   84              0.000079   return ''

FUNCTION  <SNR>248_CloseWindowIfNeeded()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:207
Called 1 time
Total time:   0.000043
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000041   0.000010     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    1              0.000001         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:271
Called 2 times
Total time:   0.000245
 Self time:   0.000197

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    2   0.000076   0.000028     if ale#util#InSandbox()
                                    return []
    2              0.000001     endif
                            
    2              0.000005     let l:combined_linters = []
                            
    6              0.000019     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    4              0.000019         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
    4              0.000003         endif
                            
    4              0.000055         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    6              0.000007     endfor
                            
    2              0.000004     return l:combined_linters

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:320
Called 2 times
Total time:   0.000183
 Self time:   0.000060

count  total (s)   self (s)
    2   0.000167   0.000044     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    2              0.000006     if type(l:filetype) isnot v:t_list
                                    return [l:filetype]
    2              0.000001     endif
                            
    2              0.000002     return l:filetype

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:376
Called 2 times
Total time:   0.000266
 Self time:   0.000245

count  total (s)   self (s)
    2              0.000004     let l:command_list = []
    2              0.000004     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    2              0.000009     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    1   0.000043   0.000031         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    1              0.000002         let l:is_dummy_sign_set = 1
    2              0.000002     endif
                            
                                " Place new items first.
    3              0.000015     for [l:line_str, l:info] in items(a:sign_map)
    1              0.000002         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
                                        endif
    1              0.000001         endif
    3              0.000003     endfor
                            
                                " Remove signs without new IDs.
    3              0.000009     for l:info in values(a:sign_map)
    2              0.000004         for l:current_id in l:info.current_id_list
    1              0.000002             if l:current_id isnot l:info.new_id
    1   0.000022   0.000017                 call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
    1              0.000001             endif
    2              0.000002         endfor
    3              0.000002     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    2              0.000006     if l:is_dummy_sign_set && !g:ale_sign_column_always
    1   0.000021   0.000016         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    2              0.000001     endif
                            
    2              0.000003     return l:command_list

FUNCTION  <SNR>17_detect_indent()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/polyglot/init.vim:2932
Called 1 time
Total time:   0.006419
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000003     if &buftype ==# 'help'
                                  return
    1              0.000001     endif
                            
                                " Do not autodetect indent if language or user sets it
    1              0.000002     if &l:shiftwidth != s:default_shiftwidth
                                  return
    1              0.000000     endif
                            
    1              0.000020     let b:sleuth_culprit = expand("<afile>:p")
    1   0.006388   0.000054     if s:guess(getline(1, 128))
    1              0.000001       return
                                endif
                                if s:guess(getline(1, 1024))
                                  return
                                endif
                                let pattern = polyglot#sleuth#GlobForFiletype(&filetype)
                                if len(pattern) == 0
                                  return
                                endif
                                let pattern = '{' . pattern . ',.git,.svn,.hg}'
                                let dir = expand('%:p:h')
                                let level = 3
                                while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && level > 0
                                  " Ignore files from homedir and root 
                                  if dir == expand('~') || dir == '/'
                                    unlet b:sleuth_culprit
                                    return
                                  endif
                                  for neighbor in glob(dir . '/' . pattern, 0, 1)[0:level]
                                    let b:sleuth_culprit = neighbor
                                    " Do not consider directories above .git, .svn or .hg
                                    if fnamemodify(neighbor, ":h:t")[0] == "."
                                      let level = 0
                                      continue
                                    endif
                                    if neighbor !=# expand('%:p') && filereadable(neighbor)
                                      if s:guess(readfile(neighbor, '', 32))
                                        return
                                      endif
                                    endif
                                  endfor
                            
                                  let dir = fnamemodify(dir, ':h')
                                  let level -= 1
                                endwhile
                            
                                let b:sleuth_culprit = "default"

FUNCTION  <SNR>233_ShrinkIfExpanded()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:1118
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     if !s:window_expanded || &filetype ==# 'tagbar' || s:expand_bufnr == -1
    1              0.000001         return
                                endif
                            
                                let tablist = []
                                for i in range(tabpagenr('$'))
                                    call extend(tablist, tabpagebuflist(i + 1))
                                endfor
                            
                                if index(tablist, s:expand_bufnr) == -1
                                    let &columns -= g:tagbar_width + 1
                                    let s:window_expanded = 0
                                    let s:expand_bufnr = -1
                                    " Only restore window position if it is available and if the
                                    " window hasn't been moved manually after the expanding
                                    if getwinposx() != -1 && getwinposx() == s:window_pos.post.x && getwinposy() == s:window_pos.post.y
                                       execute 'winpos ' . s:window_pos.pre.x . ' ' . s:window_pos.pre.y
                                    endif
                                endif
                            
                                " The window sizes may have changed due to the shrinking happening after
                                " the window closing, so equalize them again.
                                if &equalalways
                                    wincmd =
                                endif

FUNCTION  <SNR>130_GetLinterNames()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:330
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    2              0.000010     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    2              0.000003     if l:buffer_ale_linters is# 'all'
                                    return 'all'
    2              0.000001     endif
                            
                                " b:ale_linters can be set to a List.
    2              0.000005     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
    2              0.000001     endif
                            
                                " Try to get a buffer-local setting for the filetype
    2              0.000005     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
    2              0.000001     endif
                            
                                " Try to get a global setting for the filetype
    2              0.000005     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
    2              0.000001     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    2              0.000002     if g:ale_linters_explicit
                                    return []
    2              0.000001     endif
                            
                                " Try to get a default setting for the filetype
    2              0.000007     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
    2              0.000001     endif
                            
    2              0.000002     return 'all'

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:46
Called 91 times
Total time:   0.004532
 Self time:   0.001330

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
   91   0.004371   0.001169   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  ale#path#Simplify()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:15
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000005     if has('unix')
    2              0.000018         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
    2              0.000016         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  jsx_pretty#comment#update_commentstring()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim:5
Called 7 times
Total time:   0.003161
 Self time:   0.000599

count  total (s)   self (s)
    7              0.000025   let line = getline(".")
    7              0.000016   let col = col('.')
    7              0.000124   if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
    2              0.000006     let col = indent('.') + 1
    7              0.000004   endif
    7   0.001760   0.000079   let syn_start = s:syn_name(line('.'), col)
    7              0.000030   let save_cursor = getcurpos()
                            
    7              0.000034   if syn_start =~? '^jsx'
    2              0.000011     if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
    2   0.000909   0.000028     elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
    2              0.000014     elseif syn_start =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
    2              0.000002     else
    2              0.000015       let &l:commentstring = '{/* %s */}'
    2              0.000001     endif
    5              0.000003   else
    5              0.000064     let &l:commentstring = a:original
    7              0.000004   endif
                            
                              " Restore the cursor position
    7              0.000030   call setpos('.', save_cursor)

FUNCTION  <SNR>65_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 5 times
Total time:   0.000596
 Self time:   0.000100

count  total (s)   self (s)
    5   0.000592   0.000096   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:246
Called 84 times
Total time:   0.117917
 Self time:   0.003994

count  total (s)   self (s)
   84              0.000448   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
   84              0.000051   endif
                            
   84   0.072527   0.000769   call s:update_branch()
   84   0.042794   0.001021   call s:update_untracked()
                            
   84              0.000388   if exists('b:airline_head') && !empty(b:airline_head)
   79              0.000125     return b:airline_head
    5              0.000003   endif
                            
    5              0.000022   let b:airline_head = ''
    5              0.000024   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    5              0.000006   let heads = []
   15              0.000021   for vcs in vcs_priority
   10              0.000029     if !empty(b:buffer_vcs_config[vcs].branch)
    5              0.000017       let heads += [vcs]
   10              0.000005     endif
   15              0.000013   endfor
                            
   10              0.000013   for vcs in heads
    5              0.000009     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
    5              0.000002     endif
    5              0.000010     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
    5              0.000002     endif
    5   0.000503   0.000111     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    5              0.000015     let additional = b:buffer_vcs_config[vcs].untracked
    5              0.000027     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
    5              0.000017       let additional = g:airline_symbols['dirty']
    5              0.000003     endif
    5              0.000011     let b:airline_head .= additional
   10              0.000009   endfor
                            
    5              0.000008   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
    5              0.000002   endif
                            
    5              0.000006   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
    5              0.000002   endif
                            
    5              0.000018   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
    5              0.000002   endif
                            
    5              0.000008   return b:airline_head

FUNCTION  <SNR>247_GroupCmd()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:162
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000007     if s:supports_sign_groups
    3              0.000005         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  <SNR>258_RunFixer()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim:208
Called 3 times
Total time:   0.051767
 Self time:   0.000080

count  total (s)   self (s)
    3              0.000013     let l:buffer = a:options.buffer
    3              0.000006     let l:input = a:options.input
    3              0.000006     let l:index = a:options.callback_index
                            
    3              0.000013     if len(a:options.callback_list) <= l:index
    1   0.015739   0.000062         call ale#fix#ApplyFixes(l:buffer, l:input)
                            
    1              0.000002         return
    2              0.000002     endif
                            
    2              0.000024     let [l:fixer_name, l:Function] = a:options.callback_list[l:index]
                            
                                " Record new jobs started as fixer jobs.
    2              0.000023     call setbufvar(l:buffer, 'ale_job_type', 'fixer')
                            
                                " Regular fixer commands accept (buffer, [input])
    2   0.002095   0.000260     let l:result = ale#util#FunctionArgCount(l:Function) == 1   ? call(l:Function, [l:buffer])   : call(l:Function, [l:buffer, copy(l:input)])
                            
    2              0.000176     call s:RunJob(l:result, {   'buffer': l:buffer,   'input': l:input,   'callback_list': a:options.callback_list,   'callback_index': l:index,   'fixer_name': l:fixer_name,})

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 84 times
Total time:   0.008965
 Self time:   0.002992

count  total (s)   self (s)
   84              0.000461   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
   84              0.000040   endif
   84   0.006956   0.000983   return {b:source_func}()

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 2 times
Total time:   0.000081
 Self time:   0.000027

count  total (s)   self (s)
    2   0.000042   0.000011   let summary = gitgutter#hunk#summary(a:bufnr)
    2              0.000003   let summary[2] += a:count
    2   0.000035   0.000012   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>231_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:355
Called 84 times
Total time:   0.008555
 Self time:   0.001007

count  total (s)   self (s)
   84   0.008488   0.000941   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  ale#handlers#eslint#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim:38
Called 4 times
Total time:   0.002996
 Self time:   0.000065

count  total (s)   self (s)
    4   0.002991   0.000060     return ale#path#FindExecutable(a:buffer, 'javascript_eslint', s:executables)

FUNCTION  <SNR>117_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 5 times
Total time:   0.000279
 Self time:   0.000060

count  total (s)   self (s)
    5   0.000274   0.000054   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  fugitive#Find()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1054
Called 84 times
Total time:   0.035483
 Self time:   0.023302

count  total (s)   self (s)
   84              0.000395   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
   84              0.000518   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
   84              0.000053   endif
   84   0.000934   0.000737   let rev = s:Slash(a:object)
   84              0.001304   if rev =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
   84              0.000486   elseif rev =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
   84              0.000051   endif
   84              0.000274   let dir = a:0 ? a:1 : s:Dir()
   84              0.000141   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs\%(\.\.\=$\|\.\.\=/.*\|/.*\|\w:/.*\)')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return ''
                                endif
   84              0.000044   endif
   84   0.009250   0.000695   let tree = s:Tree(dir)
   84              0.000314   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
   84              0.000125   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
   84              0.000416   elseif rev =~# '^\.git/'
   84              0.000631     let f = substitute(rev, '^\.git', '', '')
   84   0.003405   0.000787     let cdir = fugitive#CommonDir(dir)
   84              0.000495     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
   84              0.000326     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
   84              0.000679     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
   84              0.000055     else
   84              0.000327       let f = simplify(dir . f)
   84              0.000052     endif
                              elseif rev ==# ':/'
                                let f = tree
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) ? "@" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$\|^$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                    if empty(commit) && len(file)
                                      let commit = repeat('0', 40)
                                    endif
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
   84              0.000053   endif
   84   0.001553   0.000743   return FugitiveVimPath(f)

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 4 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
    4              0.000051   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    4              0.000023   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    4              0.000009   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
                                let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    4              0.000002   endif
                            
    4              0.000014   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    4              0.000002   endif

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:107
Called 1 time
Total time:   0.000045
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000003   if !g:gitgutter_map_keys
                                return
    1              0.000001   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
    1              0.000005   let bufnr = bufnr('')
                            
    1   0.000032   0.000012   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
    1              0.000001     return
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>(GitGutterPrevHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>(GitGutterNextHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
                                xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
                              endif
                            
                              call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  <SNR>106_conflict_marker()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:52
Called 1 time
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
                              " Checks for git conflict markers
    1              0.000003   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    1              0.000019   if match(['rst', 'markdown'], &ft) >= 0
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
    1              0.000001   else
    1              0.000006     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    1              0.000001   endif
    1              0.000142   return search(pattern, 'nw')

FUNCTION  ale#path#FindNearestExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:82
Called 12 times
Total time:   0.008518
 Self time:   0.001285

count  total (s)   self (s)
   36              0.000120     for l:path in a:path_list
   30   0.000821   0.000352         if ale#path#IsAbsolute(l:path)
                                        let l:executable = filereadable(l:path) ? l:path : ''
   30              0.000023         else
   30   0.007113   0.000349             let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
   30              0.000022         endif
                            
   30              0.000065         if !empty(l:executable)
    6              0.000007             return l:executable
   24              0.000015         endif
   30              0.000049     endfor
                            
    6              0.000008     return ''

FUNCTION  airline#extensions#searchcount#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:27
Called 91 times
Total time:   0.013537
 Self time:   0.008877

count  total (s)   self (s)
   91              0.000121   try
   91              0.005095     let result = searchcount(#{recompute: 1, maxcount: -1})
   91              0.000355     if empty(result) || result.total ==# 0
   41              0.000077       return ''
   50              0.000035     endif
   50              0.000079     if result.incomplete ==# 1     " timed out
                                  return printf('%s [?/??]', s:search_term())
   50              0.000080     elseif result.incomplete ==# 2 " max count exceeded
                                  if result.total > result.maxcount &&  result.current > result.maxcount
                                    return printf('%s[>%d/>%d]', s:search_term(),		    result.current, result.total)
                                  elseif result.total > result.maxcount
                                    return printf('%s[%d/>%d]', s:search_term(),		    result.current, result.total)
                                  endif
   50              0.000024     endif
   50   0.005330   0.000670     return printf('%s[%d/%d]', s:search_term(),		result.current, result.total)
                              catch
                                return ''
   91              0.000102   endtry

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:110
Called 2 times
Total time:   0.000485
 Self time:   0.000218

count  total (s)   self (s)
    2              0.000006     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
    2              0.000001     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    2              0.000090     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    2              0.000008     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    2              0.000045     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    2   0.000072   0.000021     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    2   0.000239   0.000022     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    2              0.000006     return 1

FUNCTION  airline#async#nvim_vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:305
Called 24 times
Total time:   0.012515
 Self time:   0.012142

count  total (s)   self (s)
   24   0.001269   0.000950     let config = { 'buf': '', 'vcs': a:vcs, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')), 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), 'on_exit': function('s:on_exit_clean')}
   24              0.000085     if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
   24              0.000018     else
   24              0.000275       let cmd = [&shell, &shellcmdflag, a:cmd]
   24              0.000020     endif
                            
   24              0.000102     if !has_key(s:clean_jobs, a:vcs)
                                  let s:clean_jobs[a:vcs] = {}
   24              0.000015     endif
   24              0.000110     if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
   22              0.000023       return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
    2              0.000001     endif
    2              0.010261     let id = jobstart(cmd, config)
    2   0.000158   0.000104     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  <SNR>231_can_diffoff()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:5288
Called 7 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    7              0.000049   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:207
Called 91 times
Total time:   0.001863
 Self time:   0.001863

count  total (s)   self (s)
   91              0.000859   if has_key(s:contexts, a:winnr)
   91              0.000840     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 5 times
Total time:   0.001423
 Self time:   0.000227

count  total (s)   self (s)
    5   0.001415   0.000219   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 40 times
Total time:   0.005983
 Self time:   0.003197

count  total (s)   self (s)
   40              0.000239   let filetype_overrides = get(s:, 'filetype_overrides', {})
   40              0.000321   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
   40   0.003195   0.000409   if s:is_excluded_window()
                                return -1
   40              0.000020   endif
                            
   40              0.000094   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
   40              0.000021   endif
                            
   40              0.000159   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
   40              0.000021   endif
                            
   40              0.000441   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
   40              0.000025   endif
                            
   40              0.000072   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
   40              0.000019   endif
                            
   40              0.000187   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
   40              0.000032   endfor

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 9248 times
Total time:   3.951250
 Self time:   1.256624

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
 9248              0.357746     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
 9248              0.049798     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
 9248              0.005892     else
 9248   0.806826   0.077161       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
 9248   0.727201   0.072557       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
 9248   0.697889   0.068887       let guifg = s:get_syn(a:group, 'fg', 'gui')
 9248   0.679822   0.068724       let guibg = s:get_syn(a:group, 'bg', 'gui')
 9248              0.266191       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 9248              0.011562       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
 9248              0.006459       else
 9248   0.162438   0.092221         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
 9248              0.005359       endif
 9248              0.003945     endif
 9248              0.051272     let s:hl_groups[a:group] = res
 9248              0.009524     return res

FUNCTION  ale#history#Add()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:12
Called 10 times
Total time:   0.000967
 Self time:   0.000967

count  total (s)   self (s)
   10              0.000032     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
   10              0.000007     endif
                            
   10              0.000110     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   10              0.000049     if len(l:history) >= g:ale_max_buffer_history_size
   10              0.000285         let l:history = l:history[1:]
   10              0.000010     endif
                            
   10              0.000110     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   10              0.000228     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:28
Called 393 times
Total time:   0.016146
 Self time:   0.011045

count  total (s)   self (s)
  393   0.010976   0.005874   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
   50              0.000123     if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
   50              0.000035     else
                                  " shorten from beginning of string
   50              0.000679       return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  343              0.000173   else
  343              0.000474     return a:text
                              endif

FUNCTION  <lambda>4093()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:359
Called 1 time
Total time:   0.000058
 Self time:   0.000036

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>4095()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:359
Called 1 time
Total time:   0.003448
 Self time:   0.000022

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>227_FindHistoryItem()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:36
Called 2 times
Total time:   0.000076
 Self time:   0.000057

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   10   0.000041   0.000022     for l:obj in reverse(ale#history#Get(a:buffer))
   10              0.000012         if l:obj.job_id == a:job_id
    2              0.000002             return l:obj
    8              0.000003         endif
    8              0.000004     endfor
                            
                                return {}

FUNCTION  <SNR>65_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 9 times
Total time:   0.000781
 Self time:   0.000172

count  total (s)   self (s)
    9   0.000773   0.000165   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 8 times
Total time:   0.001325
 Self time:   0.000260

count  total (s)   self (s)
    8              0.000042     if getbufvar(a:bufnr, '&modified')
    6              0.000070       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    2              0.000001     else
    2              0.000026       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    8              0.000004     endif
                            
    8              0.000016     if !empty(colors)
    2   0.001092   0.000027       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    8              0.000004     endif

FUNCTION  <SNR>232_set_clean_variables()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:67
Called 2 times
Total time:   0.000578
 Self time:   0.000578

count  total (s)   self (s)
    2              0.000209   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
    2              0.000177   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
    2              0.000012     let var[a:vcs].dirty=a:val
    2              0.000003     try
    2              0.000151       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
    2              0.000015       unlet! b:airline_head
                                catch
    2              0.000003     endtry
    2              0.000001   endif

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:175
Called 2 times
Total time:   0.000184
 Self time:   0.000137

count  total (s)   self (s)
    2   0.000070   0.000023     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    2              0.000018     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
    2              0.000008     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
    2              0.000005     endif
                            
    2              0.000011     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
    2              0.000001     endif
                            
    2              0.000024     if &shell =~? 'fish$\|pwsh$'
    2              0.000008         return ['/bin/sh', '-c', l:command]
                                endif
                            
                                return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:315
Called 84 times
Total time:   0.125714
 Self time:   0.004398

count  total (s)   self (s)
   84   0.118779   0.000862   let head = airline#extensions#branch#head()
   84   0.001543   0.000969   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   84              0.000406   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   84   0.003605   0.000782   let head = airline#util#shorten(head, winwidth, minwidth)
   84              0.000451   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   84              0.000783   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  ale#linter#RemoveIgnored()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:413
Called 2 times
Total time:   0.000931
 Self time:   0.000092

count  total (s)   self (s)
                                " Apply ignore lists for linters only if needed.
    2   0.000079   0.000022     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    2   0.000045   0.000017     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
    2   0.000799   0.000046     return !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)   : a:linters

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:96
Called 70 times
Total time:   0.006397
 Self time:   0.001305

count  total (s)   self (s)
   70   0.001003   0.000508   if !coc#rpc#ready()
                                return ''
   70              0.000032   endif
   70   0.005184   0.000588   call s:client['notify'](a:method, a:args)
   70              0.000069   return ''

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:32
Called 10 times
Total time:   0.001511
 Self time:   0.001099

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   10              0.000072     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
   10              0.000006     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   10              0.000043     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
   10              0.000005     endif
                            
   10              0.000051     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   10              0.000016     if l:filetype is# ''
                                    return 1
   10              0.000005     endif
                            
                                " Do nothing for diff buffers.
   10              0.000028     if getbufvar(a:buffer, '&diff')
                                    return 1
   10              0.000005     endif
                            
                                " Do nothing for blacklisted files.
   10              0.000068     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
   10              0.000005     endif
                            
                                " Do nothing if running from command mode.
   10              0.000042     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
   10              0.000005     endif
                            
   10              0.000053     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   10              0.000014     if l:filename is# '.'
                                    return 1
   10              0.000006     endif
                            
                                " Don't start linting and so on when an operator is pending.
   10   0.000167   0.000088     if ale#util#Mode(1) is# 'no'
                                    return 1
   10              0.000005     endif
                            
                                " Do nothing if running in the sandbox.
   10   0.000274   0.000074     if ale#util#InSandbox()
                                    return 1
   10              0.000005     endif
                            
                                " Do nothing if the file is too large.
   10   0.000207   0.000074     if ale#FileTooLarge(a:buffer)
                                    return 1
   10              0.000005     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   10              0.000134     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
   10              0.000005     endif
                            
   10              0.000008     return 0

FUNCTION  <SNR>223_RunLinter()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:579
Called 10 times
Total time:   0.027014
 Self time:   0.000552

count  total (s)   self (s)
   10              0.000055     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
   10              0.000010     else
   10   0.007798   0.000174         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   10   0.019075   0.000237         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 117 times
Total time:   0.001797
 Self time:   0.001797

count  total (s)   self (s)
  117              0.000677   let ggvars = getbufvar(a:buffer, 'gitgutter')
  117              0.000685   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
  112              0.000267     return ggvars[a:varname]
    5              0.000003   endif
    5              0.000005   if a:0
    5              0.000006     return a:1
                              endif

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:83
Called 3 times
Total time:   0.000213
 Self time:   0.000202

count  total (s)   self (s)
    3              0.000019     let l:info = get(s:buffer_data, a:buffer, {})
                            
    3              0.000011     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    1   0.000016   0.000005         if ale#util#InSandbox()
                                        return
    1              0.000000         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    1              0.000002         for l:filename in l:info.file_list
                                        call delete(l:filename)
    1              0.000001         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
    3              0.000005         for l:directory in l:info.directory_list
    2              0.000090             call delete(l:directory, 'rf')
    3              0.000003         endfor
                            
    1              0.000004         call remove(s:buffer_data, a:buffer)
    3              0.000002     endif

FUNCTION  AutoPairsTryInit()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:603
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   if exists('b:autopairs_loaded')
    1              0.000001     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
                              if g:AutoPairsMapCR
                                if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
                                  let info = maparg('<CR>', 'i', 0, 1)
                                  if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
                                if old_cr !~ 'AutoPairsReturn'
                                  if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
                                  execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
                                end
                              endif
                              call AutoPairsInit()

FUNCTION  FugitiveParse()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:84
Called 5 times
Total time:   0.000092
 Self time:   0.000082

count  total (s)   self (s)
    5   0.000051   0.000040   let path = s:Slash(a:0 ? a:1 : @%)
    5              0.000021   if path !~# '^fugitive:'
    5              0.000017     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  <SNR>102_ModifierFlags()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:11
Called 91 times
Total time:   0.000509
 Self time:   0.000509

count  total (s)   self (s)
   91              0.000439   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:63
Called 637 times
Total time:   0.004937
 Self time:   0.004937

count  total (s)   self (s)
  637              0.001689   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  637              0.000364   endif
  637              0.001947   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>225_CheckForBadConfig()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim:92
Called 1 time
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
    1              0.000005     let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'   . '|^Cannot read config file'   . '|^.*Configuration for rule .* is invalid'   . '|^ImportDeclaration should appear'
                            
                                " Look for a message in the first few lines which indicates that
                                " a configuration file couldn't be found.
    2              0.000006     for l:line in a:lines[:10]
    1              0.000072         let l:match = matchlist(l:line, l:config_error_pattern)
                            
    1              0.000003         if len(l:match) > 0
                                        " Don't show the missing config error if we've disabled it.
                                        if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')&& l:match[0] is# 'ESLint couldn''t find a configuration file'
                                            return 0
                                        endif
                            
                                        return 1
    1              0.000001         endif
    2              0.000002     endfor
                            
    1              0.000001     return 0

FUNCTION  <SNR>250_UpdateCacheIfNecessary()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:78
Called 306 times
Total time:   0.002738
 Self time:   0.002738

count  total (s)   self (s)
                                " Cache is cold, so manually ask for an update.
  306              0.001188     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(   a:buffer,   g:ale_buffer_info[a:buffer].loclist)
  306              0.000163     endif

FUNCTION  <SNR>233_IsValidFile()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:3333
Called 1 time
Total time:   0.000230
 Self time:   0.000214

count  total (s)   self (s)
    1   0.000022   0.000012     call tagbar#debug#log('Checking if file is valid [' . a:fname . ']')
                            
    1              0.000003     if a:fname ==# '' || a:ftype ==# ''
                                    call tagbar#debug#log('Empty filename or type')
                                    return 0
    1              0.000001     endif
                            
    1              0.000020     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') ==# ''
                                    call tagbar#debug#log('File not readable')
                                    return 0
    1              0.000000     endif
                            
    1              0.000072     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call tagbar#debug#log('File is marked as ignored')
                                    return 0
    1              0.000000     endif
                            
    1              0.000062     let winnr = bufwinnr(a:fname)
    1              0.000005     if winnr != -1 && getwinvar(winnr, '&diff')
                                    call tagbar#debug#log('Window is in diff mode')
                                    return 0
    1              0.000000     endif
                            
    1              0.000001     if &previewwindow
                                    call tagbar#debug#log('In preview window')
                                    return 0
    1              0.000000     endif
                            
    1              0.000003     if !has_key(s:known_types, a:ftype)
    1              0.000003         if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
    1              0.000001         else
    1   0.000014   0.000008             call tagbar#debug#log('Unsupported filetype: ' . a:ftype)
    1              0.000001             return 0
                                    endif
                                endif
                            
                                return 1

FUNCTION  ale#command#StopJobs()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:261
Called 4 times
Total time:   0.000301
 Self time:   0.000239

count  total (s)   self (s)
    4              0.000034     let l:info = get(s:buffer_data, a:buffer, {})
                            
    4              0.000011     if !empty(l:info)
    4              0.000010         let l:new_map = {}
                            
    6              0.000037         for [l:job_id, l:job_type] in items(l:info.jobs)
    2              0.000008             let l:job_id = str2nr(l:job_id)
                            
    2              0.000008             if a:job_type is# 'all' || a:job_type is# l:job_type
    1   0.000073   0.000012                 call ale#job#Stop(l:job_id)
    1              0.000001             else
    1              0.000005                 let l:new_map[l:job_id] = l:job_type
    2              0.000001             endif
    6              0.000007         endfor
                            
    4              0.000020         let l:info.jobs = l:new_map
    4              0.000003     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:104
Called 7 times
Total time:   0.000635
 Self time:   0.000478

count  total (s)   self (s)
    7              0.000035     let l:buffer = bufnr('')
                            
    7              0.000018     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    7              0.000005     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    7              0.000028     if mode(1) isnot# 'n'
                                    return
    7              0.000004     endif
                            
    7   0.000153   0.000087     call s:StopCursorTimer()
                            
    7              0.000056     let l:pos = getpos('.')[0:2]
                            
    7              0.000018     if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
    7              0.000003     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    7              0.000016     if l:pos != w:last_pos
    5   0.000135   0.000044         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    5              0.000021         let w:last_pos = l:pos
    5              0.000043         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    7              0.000004     endif

FUNCTION  <SNR>98_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 288 times
Total time:   0.003192
 Self time:   0.003192

count  total (s)   self (s)
  288              0.001586     if index(a:list, a:name) == -1
  288              0.001055       call add(a:list, a:name)
  288              0.000312       return 1
                                else
                                  if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
                                  endif
                                  return 0
                                endif

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:71
Called 44 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   44              0.000172     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>248_SetListsImpl()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:84
Called 2 times
Total time:   0.000649
 Self time:   0.000404

count  total (s)   self (s)
    2              0.000061     let l:title = expand('#' . a:buffer . ':p')
                            
    2              0.000004     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    2              0.000003     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    2   0.000043   0.000022         let l:ids = s:WinFindBuf(a:buffer)
                            
    4              0.000009         for l:id in l:ids
    2              0.000012             if has('nvim')
    2   0.000137   0.000042                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
    2              0.000001             endif
    4              0.000003         endfor
    2              0.000001     endif
                            
                                " Save the current view before opening/closing any window
    2              0.000024     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    2   0.000080   0.000022     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    2              0.000002     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    2   0.000047   0.000017     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000051   0.000009         call s:CloseWindowIfNeeded(a:buffer)
    2              0.000001     endif

FUNCTION  <SNR>231_ReloadWinStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3328
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000014   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    3              0.000003     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  <SNR>247_GroupLoclistItems()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:261
Called 2 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000005     let l:grouped_items = []
    2              0.000003     let l:last_lnum = -1
                            
    2              0.000005     for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
    2              0.000002     endfor
                            
    2              0.000003     return l:grouped_items

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:189
Called 44 times
Total time:   0.001998
 Self time:   0.001414

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
   44   0.001882   0.001299   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 4 times
Total time:   0.000219
 Self time:   0.000061

count  total (s)   self (s)
    4   0.000104   0.000029   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    4   0.000111   0.000027   call s:reset_summary(a:bufnr)

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:505
Called 84 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
   84              0.000192   return s:loaded_ext

FUNCTION  <SNR>17_guess()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/polyglot/init.vim:2799
Called 1 time
Total time:   0.006333
 Self time:   0.006100

count  total (s)   self (s)
    1              0.000003     let options = {}
    1              0.000001     let ccomment = 0
    1              0.000001     let podcomment = 0
    1              0.000001     let triplequote = 0
    1              0.000001     let backtick = 0
    1              0.000002     let xmlcomment = 0
    1              0.000001     let heredoc = ''
    1              0.000001     let minindent = 10
    1              0.000001     let spaces_minus_tabs = 0
    1              0.000001     let lineno = 0
    1              0.000002     let stack = [0]
    1              0.000004     let indents = { '2': 0, '3': 0, '4': 0, '6': 0, '8': 0 }
                            
   68              0.000085     for line in a:lines
   67              0.000079       let lineno += 1
                            
   67              0.000266       if line =~# '^\s*$'
    3              0.000002         continue
   64              0.000024       endif
                            
   64              0.000193       if line =~# '^\s*/\*'
                                    let ccomment = 1
   64              0.000024       endif
   64              0.000052       if ccomment
                                    if line =~# '\*/'
                                      let ccomment = 0
                                    endif
                                    continue
   64              0.000022       endif
                            
   64              0.000115       if line =~# '^=\w'
                                    let podcomment = 1
   64              0.000023       endif
   64              0.000054       if podcomment
                                    if line =~# '^=\%(end\|cut\)\>'
                                      let podcomment = 0
                                    endif
                                    continue
   64              0.000023       endif
                            
   64              0.000050       if triplequote
                                    if line =~# '^[^"]*"""[^"]*$'
                                      let triplequote = 0
                                    endif
                                    continue
   64              0.000348       elseif line =~# '^[^"]*"""[^"]*$'
                                    let triplequote = 1
   64              0.000023       endif
                            
   64              0.000048       if backtick
                                    if line =~# '^[^`]*`[^`]*$'
                                      let backtick = 0
                                    endif
                                    continue
   64              0.000127       elseif &filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                    let backtick = 1
   64              0.000023       endif
                            
   64              0.000219       if line =~# '^\s*<\!--'
                                    let xmlcomment = 1
   64              0.000022       endif
   64              0.000050       if xmlcomment
                                    if line =~# '-->'
                                      let xmlcomment = 0
                                    endif
                                    continue
   64              0.000023       endif
                            
                                  " This is correct order because both "<<EOF" and "EOF" matches end
   64              0.000068       if heredoc != ''
                                    if line =~# heredoc
                                      let heredoc = ''
                                    endif
                                    continue
   64              0.000022       endif
   64              0.000332       let herematch = matchlist(line, '\C<<\W*\([A-Z]\+\)\s*$')
   64              0.000125       if len(herematch) > 0
                                    let heredoc = herematch[1] . '$'
   64              0.000026       endif
                            
   64              0.000090       if line[0] == "\t"
                                    let spaces_minus_tabs -= 1
   64              0.000029       else
   64              0.000071         if line[0] == " "
   53              0.000080           let spaces_minus_tabs += 1
   64              0.000028         endif
   64              0.000363         let indent = len(matchstr(line, '^ *'))
   84              0.000129         while stack[-1] > indent
   20              0.000043           call remove(stack, -1)
   84              0.000051         endwhile
                            
   64              0.000114         let indent_inc = indent - stack[-1]
                            
   64              0.000118         if indent_inc == 0 && len(stack) > 1
   33              0.000054           let indent_inc = indent - stack[-2]
   64              0.000027         endif
                            
   64              0.000145         if has_key(indents, indent_inc)
   53              0.000100           let indents[indent_inc] += 1
   53              0.000065           let prev_indent = indent
   64              0.000030         endif
                            
   64              0.000082         if stack[-1] != indent
   20              0.000047           call add(stack, indent)
   64              0.000027         endif
   64              0.000027       endif
   65              0.000039     endfor
                            
    1              0.000002     if spaces_minus_tabs < 0
                                  setlocal noexpandtab
                                  let &l:shiftwidth=&tabstop
                                  return 1
    1              0.000000     endif
                            
    1   0.000257   0.000024     let shiftwidth = s:get_shiftwidth(indents)
                            
    1              0.000001     if shiftwidth > 0
    1              0.000006       setlocal expandtab
    1              0.000006       let &l:shiftwidth=shiftwidth
    1              0.000001       try
                                    " Sunchronize tabstop with shiftwidth
    1              0.000003         let &l:softtabstop = -1
                                  catch /^Vim\%((\a\+)\)\=:E487/
                                    " -1 was not supported before Vim 7.4
                                    let &l:softtabstop = a:num_spaces
    1              0.000001       endtry
    1              0.000001       return 1
                                endif
                            
                                return 0

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:147
Called 72 times
Total time:   0.000404
 Self time:   0.000404

count  total (s)   self (s)
   72              0.000099   if s:is_vim
                                return a:client['channel']
   72              0.000038   endif
   72              0.000115   return a:client['chan_id']

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:108
Called 2 times
Total time:   0.005220
 Self time:   0.000166

count  total (s)   self (s)
    2              0.000011     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    2              0.000004     if empty(l:info)
                                    return
    2              0.000001     endif
                            
    2              0.000003     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    1              0.000003         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    2              0.000001     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    2   0.000730   0.000034     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    2              0.000014     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    2              0.000004     if !empty(l:linter_loclist)
                                    " Add the new items.
                                    call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
                                    call sort(l:info.loclist, 'ale#util#LocItemCompare')
    2              0.000001     endif
                            
    2   0.000306   0.000021     if ale#ShouldDoNothing(a:buffer)
                                    return
    2              0.000001     endif
                            
    2   0.004107   0.000034     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>106_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:17
Called 1 time
Total time:   0.000602
 Self time:   0.000602

count  total (s)   self (s)
    1              0.000007   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000002   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    1              0.000002   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
    1              0.000001   else
    1              0.000571     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  ale_linters#typescript#standard#GetExecutable()
    Defined: ~/.vim/plugged/ale/ale_linters/typescript/standard.vim:8
Called 2 times
Total time:   0.002856
 Self time:   0.000056

count  total (s)   self (s)
    2   0.002852   0.000052     return ale#path#FindExecutable(a:buffer, 'typescript_standard', [   'node_modules/standardx/bin/cmd.js',   'node_modules/standard/bin/cmd.js',   'node_modules/.bin/standard',])

FUNCTION  <SNR>233_Init()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:209
Called 11 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
   11              0.000029     if s:checked_ctags == 2 && a:silent
                                    return 0
   11              0.000016     elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
   11              0.000006     endif
                            
   11              0.000015     if !s:type_init_done
                                    call s:InitTypes()
   11              0.000006     endif
                            
   11              0.000013     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
   11              0.000006     endif
                            
   11              0.000024     let s:init_done = 1
   11              0.000010     return 1

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:93
Called 40 times
Total time:   0.039670
 Self time:   0.004633

count  total (s)   self (s)
  252              0.000437     for Fn in a:list
  252   0.038238   0.003201       let code = call(Fn, a:000)
  252              0.000344       if code != 0
   40              0.000051         return code
  212              0.000110       endif
  212              0.000140     endfor
                                return 0

FUNCTION  <SNR>62_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:187
Called 70 times
Total time:   0.004596
 Self time:   0.004213

count  total (s)   self (s)
   70   0.000919   0.000536   let channel = coc#client#get_channel(self)
   70              0.000113   if empty(channel)
                                return ''
   70              0.000031   endif
   70              0.000058   try
   70              0.000062     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
   70              0.000045     else
   70              0.001273       call call('rpcnotify', [channel, a:method] + a:args)
   70              0.000053     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
   70              0.000107   endtry

FUNCTION  <SNR>65_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 5 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    5              0.000030   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 4 times
Total time:   0.019233
 Self time:   0.019059

count  total (s)   self (s)
    4   0.000164   0.000032   call gitgutter#debug#log('[async] '.a:cmd)
                            
    4              0.000023   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    4   0.000074   0.000031   let command = s:build_command(a:cmd)
                            
    4              0.000010   if has('nvim')
    4              0.018828     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    4              0.000004   endif

FUNCTION  <SNR>101_reset_untracked_cache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:326
Called 1 time
Total time:   0.000145
 Self time:   0.000113

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    1              0.000004   if !exists('#airline')
                                " airline disabled
                                return
    1              0.000001   endif
    1              0.000016   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
    1              0.000000   endif
                            
    1              0.000023   let file = expand("%:p")
    3              0.000012   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    2   0.000056   0.000025     call airline#extensions#branch#update_untracked_config(file, vcs)
    2              0.000015     let s:vcs_config[vcs].untracked = {}
    3              0.000003   endfor

FUNCTION  <SNR>224_GatherOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:281
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     call add(a:line_list, a:line)

FUNCTION  <SNR>67_ShouldForwardNavigationBackToTmux()
    Defined: ~/.vim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim:86
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003   if g:tmux_navigator_disable_when_zoomed && s:TmuxVimPaneIsZoomed()
                                return 0
    1              0.000001   endif
    1              0.000002   return a:tmux_last_pane || a:at_tab_page_edge

FUNCTION  <SNR>114_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 140 times
Total time:   0.014426
 Self time:   0.006619

count  total (s)   self (s)
  140              0.000867     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  140   0.002394   0.001915     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
  140              0.000081     endif
  140              0.000154     if condition
                                  call a:builder.add_raw('%(')
  140              0.000072     endif
  140   0.009594   0.002266     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  140              0.000169     if condition
                                  call a:builder.add_raw('%)')
  140              0.000091     endif

FUNCTION  <SNR>238_save_last_seen_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:415
Called 4 times
Total time:   0.000107
 Self time:   0.000038

count  total (s)   self (s)
    4   0.000105   0.000036   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:49
Called 588 times
Total time:   0.006668
 Self time:   0.006668

count  total (s)   self (s)
  588              0.001557   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  588              0.000323   endif
  588              0.002010   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  588              0.001848   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  ale#events#QuitRecently()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:19
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000009     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    2              0.000010     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  <SNR>101_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:199
Called 84 times
Total time:   0.041772
 Self time:   0.012523

count  total (s)   self (s)
   84              0.002144   let file = expand("%:p")
   84              0.000788   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   84              0.000051   endif
                            
   84              0.000163   let needs_update = 1
   84              0.000587   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  252              0.000748   for vcs in keys(s:vcs_config)
  168              0.001071     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  168              0.000094     endif
  168              0.000594     if has_key(s:vcs_config[vcs].untracked, file)
   60              0.000085       let needs_update = 0
   60   0.001737   0.000735       call airline#extensions#branch#update_untracked_config(file, vcs)
  168              0.000084     endif
  252              0.000203   endfor
                            
   84              0.000118   if !needs_update
   60              0.000059     return
   24              0.000017   endif
                            
   72              0.000190   for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
   48   0.000684   0.000430     if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
   48   0.000640   0.000392     elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
   24              0.000029       continue
   24              0.000011     endif
   24              0.000067     let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
   24              0.000127     if index(vcs_checks, 'untracked') > -1
   24   0.014274   0.000325       call airline#async#vcs_untracked(config, file, vcs)
   24              0.000017     endif
                                " Check clean state of repo
   24              0.000099     if index(vcs_checks, 'dirty') > -1
   24   0.014194   0.000397       call airline#async#vcs_clean(config.dirty, file, vcs)
   24              0.000057     endif
   48              0.000098   endfor

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:35
Called 5844 times
Total time:   3.031052
 Self time:   0.073936

count  total (s)   self (s)
 5844   3.028380   0.071264     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:72
Called 3 times
Total time:   0.000177
 Self time:   0.000107

count  total (s)   self (s)
    3              0.000006     if s:has_nvim_highlight
    3   0.000132   0.000062         call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
    3              0.000002     endif

FUNCTION  <SNR>98_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 36992 times
Total time:   2.624410
 Self time:   2.624410

count  total (s)   self (s)
36992              0.052577     let color = ''
36992              1.079650     if hlexists(a:group)
25588              0.611149       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
36992              0.025886     endif
36992              0.083870     if empty(color) || color == -1
                                  " should always exist
11404              0.421097       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
11404              0.027109       if empty(color) || color == -1
                                    let color = 'NONE'
11404              0.006016       endif
36992              0.016597     endif
36992              0.040239     return color

FUNCTION  <SNR>114_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 44 times
Total time:   0.017691
 Self time:   0.003264

count  total (s)   self (s)
  256              0.000410   for key in a:keys
  212              0.000693     if (key == 'warning' || key == 'error') && !a:context.active
   72              0.000060       continue
  140              0.000070     endif
  140   0.015782   0.001356     call s:add_section(a:builder, a:context, key)
  184              0.000174   endfor

FUNCTION  <SNR>113_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 96 times
Total time:   0.150801
 Self time:   0.002369

count  total (s)   self (s)
   96   0.134337   0.001202   if airline#builder#should_change_group(a:prev_group, a:group)
    8   0.015418   0.000121     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
   88              0.000070   else
   88              0.000436     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>224_FormatFilename()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:156
Called 2 times
Total time:   0.000074
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000005     let l:filename = a:filename
                            
    2              0.000004     if !empty(a:mappings)
                                    let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
    2              0.000001     endif
                            
    2              0.000004     if !empty(a:modifiers)
                                    let l:filename = fnamemodify(l:filename, a:modifiers)
    2              0.000001     endif
                            
    2   0.000046   0.000016     return ale#Escape(l:filename)

FUNCTION  <SNR>238_is_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000008   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>250_GetCounts()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:97
Called 140 times
Total time:   0.006404
 Self time:   0.003562

count  total (s)   self (s)
  140   0.002589   0.001121     if !s:BufferCacheExists(a:buffer)
                                    return s:CreateCountDict()
  140              0.000070     endif
                            
  140   0.002878   0.001503     call s:UpdateCacheIfNecessary(a:buffer)
                            
  140              0.000344     return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>65_winshell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000039   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:269
Called 4 times
Total time:   0.000205
 Self time:   0.000137

count  total (s)   self (s)
    4   0.000108   0.000040     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                            
    4              0.000027     if type(l:linter_mappings) is v:t_list
                                    return l:linter_mappings
    4              0.000002     endif
                            
    4              0.000007     let l:name = a:name
                            
    4              0.000011     if !has_key(l:linter_mappings, l:name)
                                    " Use * as a default setting for all tools.
    4              0.000006         let l:name = '*'
    4              0.000002     endif
                            
    4              0.000016     return get(l:linter_mappings, l:name, [])

FUNCTION  ale#fix#Fix()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim:345
Called 1 time
Total time:   0.019878
 Self time:   0.000593

count  total (s)   self (s)
    1              0.000007     if a:fixing_flag isnot# ''&& a:fixing_flag isnot# '!'&& a:fixing_flag isnot# 'save_file'
                                    throw "fixing_flag must be '', '!', or 'save_file'"
    1              0.000001     endif
                            
    1              0.000001     try
    1   0.000521   0.000029         let l:callback_list = s:GetCallbacks(a:buffer, a:fixing_flag, a:000)
                                catch /E700\|BADNAME/
                                    if a:fixing_flag isnot# '!'
                                        let l:function_name = join(split(split(v:exception, ':')[3]))
                                        let l:echo_message = printf(   'There is no fixer named `%s`. Check :ALEFixSuggest',   l:function_name,)
                                        execute 'echom l:echo_message'
                                    endif
                            
                                    return 0
    1              0.000001     endtry
                            
    1              0.000003     if empty(l:callback_list)
                                    if a:fixing_flag is# ''
                                        execute 'echom ''No fixers have been defined. Try :ALEFixSuggest'''
                                    endif
                            
                                    return 0
    1              0.000001     endif
                            
    1   0.000105   0.000017     call ale#command#StopJobs(a:buffer, 'fixer')
                                " Clean up any files we might have left behind from a previous run.
    1   0.000064   0.000021     call ale#command#RemoveManagedFiles(a:buffer)
    1   0.000208   0.000024     call ale#fix#InitBufferData(a:buffer, a:fixing_flag)
                            
    1   0.000078   0.000045     silent doautocmd <nomodeline> User ALEFixPre
                            
    1   0.018848   0.000403     call s:RunFixer({   'buffer': a:buffer,   'input': g:ale_fix_buffer_data[a:buffer].lines_before,   'callback_index': 0,   'callback_list': l:callback_list,})
                            
    1              0.000003     return 1

FUNCTION  <SNR>81_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:40
Called 9 times
Total time:   0.005052
 Self time:   0.004922

count  total (s)   self (s)
                              " Remove any previous match.
    9   0.000209   0.000079   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    9              0.000047   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    9              0.000005   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    9              0.000025   let c_lnum = line('.')
    9              0.000021   let c_col = col('.')
    9              0.000011   let before = 0
                            
    9              0.000037   let text = getline(c_lnum)
    9              0.000264   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    9              0.000024   if empty(matches)
                                let [c_before, c] = ['', '']
    9              0.000007   else
    9              0.000051     let [c_before, c] = matches[1:2]
    9              0.000006   endif
    9              0.000179   let plist = split(&matchpairs, '.\zs[:,]')
    9              0.000037   let i = index(plist, c)
    9              0.000013   if i < 0
                                " not found, in Insert mode try character before the cursor
    7              0.000030     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    7              0.000004     endif
    7              0.000008     if i < 0
                                  " not found, nothing to do
    7              0.000007       return
                                endif
    2              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000003   if i % 2 == 0
    1              0.000002     let s_flags = 'nW'
    1              0.000003     let c2 = plist[i + 1]
    1              0.000001   else
    1              0.000002     let s_flags = 'nbW'
    1              0.000002     let c2 = c
    1              0.000003     let c = plist[i - 1]
    2              0.000001   endif
    2              0.000003   if c == '['
                                let c = '\['
                                let c2 = '\]'
    2              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000003   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    2              0.000001   endif
                            
    2              0.000021   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    2              0.000002   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
    2              0.000011     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    2              0.000002     try
    2              0.001031       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    2              0.000002     endtry
    2              0.000001   endif
                            
                              " Limit the search to lines visible in the window.
    2              0.000007   let stoplinebottom = line('w$')
    2              0.000004   let stoplinetop = line('w0')
    2              0.000004   if i % 2 == 0
    1              0.000005     let stopline = stoplinebottom
    1              0.000001   else
    1              0.000004     let stopline = stoplinetop
    2              0.000001   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000007   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    2              0.000001   else
    2              0.000009     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000001   endif
    2              0.000002   try
    2              0.002250     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    2              0.000002   endtry
                            
    2              0.000003   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    2              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    2              0.000006   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    2              0.000005     if exists('*matchaddpos')
    2              0.000295       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    2              0.000001     endif
    2              0.000007     let w:paren_hl_on = 1
    2              0.000001   endif

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:136
Called 3 times
Total time:   0.002562
 Self time:   0.000656

count  total (s)   self (s)
    3              0.000030     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    3   0.000211   0.000034     call ale#highlight#RemoveHighlights()
                            
   13              0.000023     for l:item in l:item_list
   10              0.000025         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
   10              0.000015         elseif l:item.type is# 'I'
    2              0.000003             let l:group = 'ALEInfo'
    8              0.000023         elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
    8              0.000004         else
    8              0.000011             let l:group = 'ALEError'
   10              0.000005         endif
                            
   10              0.000106         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
   10   0.001862   0.000133         call s:highlight_range(l:item.bufnr, l:range, l:group)
   13              0.000011     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    3              0.000006     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
    3              0.000002     endif

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:196
Called 4 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
    4              0.000114   let p = resolve(expand('#'.a:bufnr.':p'))
    4              0.000041   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    4              0.000011   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    4              0.000002   endif
    4              0.000007   return g:gitgutter_diff_base

FUNCTION  <SNR>52_SetUpForNewFiletype()
    Defined: ~/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim:520
Called 1 time
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    1              0.000002     let filetype = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
    1              0.000005     if filetype =~# '\.' && !has_key(s:delimiterMap, filetype)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let filetype = i
                                            break
                                        endif
                                    endfor
    1              0.000001     endif
                            
    1              0.000003     let b:NERDSexyComMarker = ''
                            
    1              0.000004     if has_key(s:delimiterMap, filetype)
    1              0.000005         let b:NERDCommenterDelims = s:delimiterMap[filetype]
    5              0.000006         for i in ['left', 'leftAlt', 'right', 'rightAlt']
    4              0.000009             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = ''
    4              0.000002             endif
    5              0.000002         endfor
    3              0.000003         for i in ['nested', 'nestedAlt']
    2              0.000004             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = 0
    2              0.000001             endif
    3              0.000001         endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
    1              0.000006         let b:NERDCommenterFirstInit = getbufvar(1,'NERDCommenterFirstInit')
    1              0.000005         if exists('g:NERDAltDelims_'.filetype) && eval('g:NERDAltDelims_'.filetype) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
    1              0.000000         endif
                                else
                                    let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    1              0.000000     endif
                            

FUNCTION  ale#handlers#eslint#GetCommand()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim:71
Called 2 times
Total time:   0.001508
 Self time:   0.000075

count  total (s)   self (s)
    2   0.001340   0.000022     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
    2   0.000047   0.000018     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
    2   0.000115   0.000029     return ale#node#Executable(a:buffer, l:executable)   . (!empty(l:options) ? ' ' . l:options : '')   . ' -f json --stdin --stdin-filename %s'

FUNCTION  <SNR>247_BuildSignMap()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:307
Called 2 times
Total time:   0.000229
 Self time:   0.000198

count  total (s)   self (s)
    2   0.000046   0.000015     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    2              0.000003     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    2              0.000008     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    2              0.000001     else
    2              0.000004         let l:selected_grouped_items = a:grouped_items
    2              0.000001     endif
                            
    2              0.000003     let l:sign_map = {}
    2              0.000004     let l:sign_offset = g:ale_sign_offset
                            
    3              0.000010     for [l:line, l:sign_id, l:name] in a:current_sign_list
    1              0.000013         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
    1              0.000003         if l:sign_id > l:sign_offset
    1              0.000003             let l:sign_offset = l:sign_id
    1              0.000001         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
    1              0.000005         call add(l:sign_info.current_id_list, l:sign_id)
    1              0.000003         call add(l:sign_info.current_name_list, l:name)
                            
    1              0.000004         let l:sign_map[l:line] = l:sign_info
    3              0.000003     endfor
                            
    2              0.000004     for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
    2              0.000003     endfor
                            
    2              0.000003     return l:sign_map

FUNCTION  ale#node#Executable()
    Defined: ~/.vim/plugged/ale/autoload/ale/node.vim:14
Called 2 times
Total time:   0.000086
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000008     if has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
    2              0.000001     endif
                            
    2   0.000061   0.000021     return ale#Escape(a:executable)

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:18
Called 168 times
Total time:   0.005797
 Self time:   0.005797

count  total (s)   self (s)
  168              0.000955   if !exists(':CocCommand')
                                return ''
  168              0.000113   endif
  168              0.000875   let _backup = get(g:, 'coc_stl_format', '')
  168              0.000478   let is_err = (a:type  is# 'error')
  168              0.000181   if is_err
   84              0.000465     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
   84              0.000055   else
   84              0.000458     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
  168              0.000130   endif
  168              0.000582   let info = get(b:, 'coc_diagnostic_info', {})
  168              0.000525   if empty(info) | return '' | endif
                            
                            
                              let cnt = get(info, a:type, 0)
                              if !empty(_backup)
                                let g:coc_stl_format = _backup
                              endif
                            
                              if empty(cnt)
                                return ''
                              else
                                let lnum = printf('(L%d)', (info.lnums)[is_err ? 0 : 1])
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt.lnum
                              endif

FUNCTION  <SNR>223_GetLintFileValues()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:607
Called 2 times
Total time:   0.028784
 Self time:   0.000449

count  total (s)   self (s)
    2              0.000006     let l:deferred_list = []
    2              0.000005     let l:new_slots = []
                            
   12              0.000023     for [l:lint_file, l:linter] in a:slots
   10   0.000141   0.000098         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
   10              0.000008         endwhile
                            
   10   0.000104   0.000066         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
   10              0.000007         else
                                        " If we have the value now, coerce it to 0 or 1.
   10              0.000020             let l:lint_file = l:lint_file is 1
   10              0.000006         endif
                            
   10              0.000046         call add(l:new_slots, [l:lint_file, l:linter])
   12              0.000010     endfor
                            
    2              0.000005     if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
    2              0.000002     else
    2   0.028281   0.000027         call a:Callback(l:new_slots)
    2              0.000002     endif

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:58
Called 1 time
Total time:   0.000040
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000038   0.000006     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    1              0.000002     let l:obj.output = a:output

FUNCTION  <SNR>241_StopCursorTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:56
Called 7 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    7              0.000019     if s:cursor_timer != -1
    5              0.000014         call timer_stop(s:cursor_timer)
    5              0.000009         let s:cursor_timer = -1
    7              0.000004     endif

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim:64
Called 4 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    4              0.000033   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * call s:autocmd_handler()
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    4              0.000002   endif

FUNCTION  ale#path#FindExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:102
Called 10 times
Total time:   0.008321
 Self time:   0.000525

count  total (s)   self (s)
   10   0.000405   0.000149     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
   10              0.000009     endif
                            
   10   0.007531   0.000148     let l:nearest = ale#path#FindNearestExecutable(a:buffer, a:path_list)
                            
   10              0.000022     if !empty(l:nearest)
    4              0.000004         return l:nearest
    6              0.000004     endif
                            
    6   0.000270   0.000114     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  <SNR>91_check_defined_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:47
Called 4 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    4              0.000028   if !exists('w:airline_section_{a:name}')
    4              0.000024     let w:airline_section_{a:name} = g:airline_section_{a:name}
    4              0.000003   endif

FUNCTION  <SNR>232_set_clean_jobs_variable()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:80
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000018   if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
    2              0.000003   endif
    2              0.000020   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  tagbar#debug#log()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar/debug.vim:30
Called 5 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    5              0.000010     if s:debug_enabled
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
    5              0.000004     endif

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 1279 times
Total time:   0.014626
 Self time:   0.014626

count  total (s)   self (s)
 1279              0.004533   let nr = get(a:000, 0, 0)
 1279              0.003089   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
 1279              0.000866   else
 1279              0.003467     return winwidth(nr)
                              endif

FUNCTION  <SNR>224_TemporaryFilename()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:132
Called 2 times
Total time:   0.000119
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000020     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    2              0.000003     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
    2              0.000001     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    2   0.000081   0.000026     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <SNR>238_process_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:310
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000002   let offset = 0
    4              0.000007   while offset < a:to_count
    2              0.000004     let line_number = a:to_line + offset
    2              0.000007     call add(a:modifications, [line_number, 'modified'])
    2              0.000004     let offset += 1
    4              0.000003   endwhile

FUNCTION  ale#fixers#generic#RemoveTrailingBlankLines()
    Defined: ~/.vim/plugged/ale/autoload/ale/fixers/generic.vim:4
Called 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000006     let l:end_index = len(a:lines) - 1
                            
    1              0.000007     while l:end_index > 0 && empty(a:lines[l:end_index])
                                    let l:end_index -= 1
    1              0.000001     endwhile
                            
    1              0.000050     return a:lines[:l:end_index]

FUNCTION  <SNR>249_highlight_range()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:122
Called 10 times
Total time:   0.001729
 Self time:   0.000275

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
   10   0.001712   0.000258     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  <SNR>106_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:185
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000002   if !exists('#airline')
                                " airline disabled
                                return
    1              0.000000   endif
    1              0.000004   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
                                return
    1              0.000000   endif
    1              0.000021   unlet! b:airline_whitespace_check
    1              0.000002   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    1              0.000000   endif
    1              0.000002   let b:airline_ws_changedtick = b:changedtick

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:61
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000014     if !isdirectory(a:dir)
    1              0.000001         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>99_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 84 times
Total time:   0.000876
 Self time:   0.000876

count  total (s)   self (s)
   84              0.000823   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:296
Called 8 times
Total time:   0.000261
 Self time:   0.000198

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    8              0.000116   let g:airline#visual_active = (mode() =~? '[vs]')
    8   0.000127   0.000064   call airline#update_tabline()

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:239
Called 3 times
Total time:   0.000269
 Self time:   0.000269

count  total (s)   self (s)
    3              0.000006     let l:msg = a:format_string
    3              0.000007     let l:severity = g:ale_echo_msg_warning_str
    3              0.000012     let l:code = get(a:item, 'code', '')
    3              0.000013     let l:type = get(a:item, 'type', 'E')
    3              0.000010     let l:linter_name = get(a:item, 'linter_name', '')
    3              0.000015     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
    3              0.000005     if l:type is# 'E'
    3              0.000007         let l:severity = g:ale_echo_msg_error_str
                                elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
    3              0.000002     endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
    3              0.000077     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
    3              0.000024     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
    3              0.000021     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                " Replace %s with the text.
    3              0.000023     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                " Windows may insert carriage return line endings (^M), strip these characters.
    3              0.000013     let l:msg = substitute(l:msg, '\r', '', 'g')
                            
    3              0.000004     return l:msg

FUNCTION  ale#events#QuitEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:14
Called 1 time
Total time:   0.000034
 Self time:   0.000021

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    1   0.000031   0.000018     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  ale#util#JoinNeovimOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:59
Called 3 times
Total time:   0.000118
 Self time:   0.000114

count  total (s)   self (s)
    3              0.000005     if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
    3              0.000002     endif
                            
    3              0.000012     let l:lines = a:data[:-2]
                            
    3              0.000006     if len(a:data) > 1
    1              0.000004         let l:lines[0] = a:last_line . l:lines[0]
    1              0.000002         let l:new_last_line = a:data[-1]
    2              0.000001     else
    2              0.000009         let l:new_last_line = a:last_line . get(a:data, 0, '')
    3              0.000002     endif
                            
    4              0.000009     for l:line in l:lines
    1   0.000013   0.000009         call a:callback(a:job, l:line)
    4              0.000004     endfor
                            
    3              0.000004     return l:new_last_line

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:442
Called 2 times
Total time:   0.000991
 Self time:   0.000238

count  total (s)   self (s)
    2              0.000008     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    2              0.000001     endif
                            
                                " Find the current markers
    2   0.000162   0.000030     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    2   0.000109   0.000033     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    2   0.000072   0.000022     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    2   0.000260   0.000031     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    2   0.000295   0.000029     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    2              0.000006     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    2              0.000001     endif
                            
    5              0.000009     for l:command in l:command_list
    3              0.000028         silent! execute l:command
    5              0.000004     endfor
                            
                                " Reset the sign column color when there are no more errors.
    2              0.000005     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    2              0.000001     endif

FUNCTION  <SNR>101_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:145
Called 84 times
Total time:   0.006627
 Self time:   0.005736

count  total (s)   self (s)
   84   0.001567   0.000676   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   84              0.000049   else
   84              0.000271     let s:vcs_config['mercurial'].branch = ''
   84              0.000052   endif

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:82
Called 3 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    3              0.000014     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
    3              0.000002     endif
                            
    3              0.000003     return 0

FUNCTION  <SNR>67_TmuxAwareNavigate()
    Defined: ~/.vim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim:93
Called 1 time
Total time:   0.113325
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000010   let nr = winnr()
    1              0.000007   let tmux_last_pane = (a:direction == 'p' && s:tmux_is_last_pane)
    1              0.000002   if !tmux_last_pane
    1   0.113252   0.000020     call s:VimNavigate(a:direction)
    1              0.000000   endif
    1              0.000004   let at_tab_page_edge = (nr == winnr())
                              " Forward the switch panes command to tmux if:
                              " a) we're toggling between the last tmux pane;
                              " b) we tried switching windows in vim but it didn't have effect.
    1   0.000022   0.000014   if s:ShouldForwardNavigationBackToTmux(tmux_last_pane, at_tab_page_edge)
                                if g:tmux_navigator_save_on_switch == 1
                                  try
                                    update " save the active buffer. See :help update
                                  catch /^Vim\%((\a\+)\)\=:E32/ " catches the no file name error
                                  endtry
                                elseif g:tmux_navigator_save_on_switch == 2
                                  try
                                    wall " save all the buffers. See :help wall
                                  catch /^Vim\%((\a\+)\)\=:E141/ " catches the no file name error
                                  endtry
                                endif
                                let args = 'select-pane -t ' . shellescape($TMUX_PANE) . ' -' . tr(a:direction, 'phjkl', 'lLDUR')
                                silent call s:TmuxCommand(args)
                                if s:NeedsVitalityRedraw()
                                  redraw!
                                endif
                                let s:tmux_is_last_pane = 1
    1              0.000000   else
    1              0.000002     let s:tmux_is_last_pane = 0
    1              0.000000   endif

FUNCTION  airline#extensions#coc#get_current_function()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:51
Called 91 times
Total time:   0.000661
 Self time:   0.000661

count  total (s)   self (s)
   91              0.000588   return get(b:, 'coc_current_function', '')

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:24
Called 10 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
   10              0.000068     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   10              0.000044     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  EasyMotion#is_active()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:775
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     return s:EasyMotion_is_active

FUNCTION  ale#command#ResetCwd()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:39
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000009     if has_key(s:buffer_data, a:buffer)
    3              0.000009         let s:buffer_data[a:buffer].cwd = v:null
    3              0.000002     endif

FUNCTION  ale#sign#ParseSignsWithGetPlaced()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:205
Called 2 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    2              0.000027     let l:signs = sign_getplaced(a:buffer, { 'group': s:supports_sign_groups ? 'ale' : '' })[0].signs
    2              0.000004     let l:result = []
    2              0.000004     let l:is_dummy_sign_set = 0
                            
    3              0.000009     for l:sign in l:signs
    1              0.000003         if l:sign['name'] is# 'ALEDummySign'
                                        let l:is_dummy_sign_set = 1
    1              0.000001         else
    1              0.000011             call add(l:result, [   str2nr(l:sign['lnum']),   str2nr(l:sign['id']),   l:sign['name'],])
    1              0.000001         endif
    3              0.000003     endfor
                            
    2              0.000008     return [l:is_dummy_sign_set, l:result]

FUNCTION  <SNR>29_dopopd()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:585
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   if !exists('w:fzf_pushd')
    1              0.000001     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  airline#extensions#tagbar#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:24
Called 36 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
   36              0.000168   if getwinvar(a:2.winnr, '&filetype') == 'tagbar'
                                return -1
   36              0.000020   endif

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:192
Called 2 times
Total time:   0.001146
 Self time:   0.000332

count  total (s)   self (s)
    2              0.000003     let l:temporary_file = ''
    2              0.000003     let l:command = a:command
                            
    2              0.000004     if !empty(a:cwd)
    2   0.000134   0.000024         let l:command = ale#command#CdString(a:cwd) . l:command
    2              0.000001     endif
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    2              0.000016     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    2              0.000009     if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    2              0.000001     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    2              0.000004     if l:command =~# '%s'
    2              0.000037         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    2   0.000129   0.000056         let l:command = substitute(   l:command,   s:path_format_regex,   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',   'g')
    2              0.000001     endif
                            
    2              0.000010     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(   l:command,   '\v\%t(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',   'g')
    2              0.000001     endif
                            
                                " Finish formatting so %% becomes %.
    2              0.000011     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    2              0.000006     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    2   0.000138   0.000018         let l:temporary_file = s:TemporaryFilename(a:buffer)
    2   0.000045   0.000019         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    2              0.000001     endif
                            
    2   0.000545   0.000060     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
    2              0.000011     return [l:temporary_file, l:command, l:file_created]

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:42
Called 1204 times
Total time:   0.015017
 Self time:   0.013295

count  total (s)   self (s)
 1204   0.006391   0.004670   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1204              0.000697   endif
 1204              0.001497   return a:text

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 8 times
Total time:   0.000250
 Self time:   0.000250

count  total (s)   self (s)
    8              0.000012   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    8              0.000004   endif

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim:10
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000012     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:471
Called 34 times
Total time:   0.000221
 Self time:   0.000221

count  total (s)   self (s)
   34              0.000203     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  <SNR>223_StopCurrentJobs()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:449
Called 2 times
Total time:   0.000360
 Self time:   0.000148

count  total (s)   self (s)
    2              0.000015     let l:info = get(g:ale_buffer_info, a:buffer, {})
    2   0.000201   0.000028     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    2              0.000004     if a:clear_lint_file_jobs
    1   0.000053   0.000015         call ale#command#StopJobs(a:buffer, 'file_linter')
    1              0.000004         let l:info.active_linter_list = []
    1              0.000001     else
    1              0.000003         let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
    6              0.000013         for [l:lint_file, l:linter] in a:linter_slots
    5              0.000008             if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
    5              0.000003             endif
    6              0.000004         endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
    1              0.000009         call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
    2              0.000002     endif

FUNCTION  ale#path#IsAbsolute()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:117
Called 30 times
Total time:   0.000469
 Self time:   0.000469

count  total (s)   self (s)
   30              0.000229     if has('win32') && a:filename[:0] is# '\'
                                    return 1
   30              0.000020     endif
                            
                                " Check for /foo and C:\foo, etc.
   30              0.000130     return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:424
Called 10 times
Total time:   0.007624
 Self time:   0.000286

count  total (s)   self (s)
   10              0.000062     let l:Executable = a:linter.executable
                            
   10   0.007544   0.000207     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>250_GetFirstProblems()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:108
Called 166 times
Total time:   0.006640
 Self time:   0.003620

count  total (s)   self (s)
  166   0.002980   0.001323     if !s:BufferCacheExists(a:buffer)
                                    return {}
  166              0.000078     endif
                            
  166   0.002774   0.001410     call s:UpdateCacheIfNecessary(a:buffer)
                            
  166              0.000403     return g:ale_buffer_info[a:buffer].first_problems

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:82
Called 316 times
Total time:   0.001527
 Self time:   0.001527

count  total (s)   self (s)
  316              0.001381     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:184
Called 48 times
Total time:   0.104618
 Self time:   0.001532

count  total (s)   self (s)
   48              0.000679     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   48   0.103897   0.000810     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#extensions#tagbar#currenttag()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:32
Called 91 times
Total time:   0.004173
 Self time:   0.003043

count  total (s)   self (s)
   91              0.000420   if get(w:, 'airline_active', 0)
   84              0.000134     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
   84              0.000048     endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
   84              0.000378     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   11   0.001295   0.000165       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags, get(g:, 'airline#extensions#tagbar#searchmethod', 'nearest-stl'))
   11              0.000035       let s:airline_tagbar_last_lookup_time = localtime()
   84              0.000046     endif
   84              0.000240     return s:airline_tagbar_last_lookup_val
    7              0.000003   endif
    7              0.000006   return ''

FUNCTION  <SNR>98_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 2922 times
Total time:   4.408518
 Self time:   0.164290

count  total (s)   self (s)
 2922              0.006453     if pumvisible()
                                  return
 2922              0.001408     endif
 2922              0.010524     let group = a:from.'_to_'.a:to.a:suffix
 2922   1.653263   0.025723     let l:from = airline#themes#get_highlight(a:from.a:suffix)
 2922   1.433379   0.029868     let l:to = airline#themes#get_highlight(a:to.a:suffix)
 2922              0.003155     if a:inverse
   12              0.000061       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
 2910              0.001564     else
 2910              0.013806       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
 2922              0.001452     endif
 2922              0.019511     let a:dict[group] = colors
 2922   1.248343   0.035167     call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>239_handle_double_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 4 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    4              0.000021   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    4              0.000002   endif
                            
    4              0.000004   return a:modified_lines

FUNCTION  ale#engine#ignore#Exclude()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine/ignore.vim:25
Called 2 times
Total time:   0.000753
 Self time:   0.000647

count  total (s)   self (s)
    2   0.000133   0.000028     let l:names_to_remove = ale#engine#ignore#GetList(a:filetype, a:config)
    2              0.000005     let l:filtered_linters = []
                            
   16              0.000025     for l:linter in a:all_linters
   14              0.000068         let l:name_list = [l:linter.name] + l:linter.aliases
   14              0.000029         let l:should_include = 1
                            
   28              0.000051         for l:name in l:name_list
   14              0.000046             if index(l:names_to_remove, l:name) >= 0
                                            let l:should_include = 0
                                            break
   14              0.000009             endif
   28              0.000020         endfor
                            
   14              0.000064         if a:disable_lsp && has_key(l:linter, 'lsp') && l:linter.lsp isnot# ''
    4              0.000008             let l:should_include = 0
   14              0.000009         endif
                            
   14              0.000021         if l:should_include
   10              0.000032             call add(l:filtered_linters, l:linter)
   14              0.000009         endif
   16              0.000013     endfor
                            
    2              0.000005     return l:filtered_linters

FUNCTION  <SNR>225_parseJSON()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim:117
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000001     let l:parsed = []
                            
    2              0.000003     for l:line in a:lines
    1              0.000001         try
    1              0.000018             let l:parsed = extend(l:parsed, json_decode(l:line))
                                    catch
    1              0.000001         endtry
    2              0.000001     endfor
                            
    1              0.000003     if type(l:parsed) != v:t_list || empty(l:parsed)
                                    return []
    1              0.000000     endif
                            
    1              0.000002     let l:errors = l:parsed[0]['messages']
                            
    1              0.000001     if empty(l:errors)
    1              0.000001         return []
                                endif
                            
                                let l:output = []
                            
                                for l:error in l:errors
                                    let l:obj = ({   'lnum': get(l:error, 'line', 0),   'text': get(l:error, 'message', ''),   'type': 'E',})
                            
                                    if get(l:error, 'severity', 0) is# 1
                                        let l:obj.type = 'W'
                                    endif
                            
                                    if has_key(l:error, 'ruleId')
                                        let l:code = l:error['ruleId']
                            
                                        " Sometimes ESLint returns null here
                                        if !empty(l:code)
                                            let l:obj.code = l:code
                                        endif
                                    endif
                            
                                    if has_key(l:error, 'column')
                                        let l:obj.col = l:error['column']
                                    endif
                            
                                    if has_key(l:error, 'endColumn')
                                        let l:obj.end_col = l:error['endColumn'] - 1
                                    endif
                            
                                    if has_key(l:error, 'endLine')
                                        let l:obj.end_lnum = l:error['endLine']
                                    endif
                            
                                    call add(l:output, l:obj)
                                endfor
                            
                                return l:output

FUNCTION  <SNR>232_on_exit_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:87
Called 2 times
Total time:   0.000677
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000016   let buf=self.buf
    2   0.000630   0.000051   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
    2              0.000014   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
    2              0.000012     call remove(s:clean_jobs[self.vcs], self.file)
    2              0.000001   endif

FUNCTION  <SNR>23_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:51
Called 45 times
Total time:   0.102487
 Self time:   0.001865

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
   45              0.000114   if &buftype is# 'popup'
                                return
   45              0.000022   endif
                            
   45              0.000117   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
   45              0.000020   endif
   45              0.000104   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   45              0.000543   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   45              0.000627   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
   44              0.000039     return
    1              0.000001   endif
    1              0.000010   let g:airline_last_window_changed = l:key
    1   0.000022   0.000017   call s:init()
    1   0.100632   0.000013   call airline#update_statusline()

FUNCTION  <SNR>248_ShouldOpen()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:40
Called 3 times
Total time:   0.000078
 Self time:   0.000041

count  total (s)   self (s)
    3   0.000058   0.000021     let l:val = ale#Var(a:buffer, 'open_list')
    3              0.000010     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    3              0.000008     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>115_Lint()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:99
Called 2 times
Total time:   0.031734
 Self time:   0.000363

count  total (s)   self (s)
                                " Use the filetype from the buffer
    2              0.000023     let l:filetype = getbufvar(a:buffer, '&filetype')
    2   0.001048   0.000043     let l:linters = ale#linter#Get(l:filetype)
    2   0.000987   0.000056     let l:linters = ale#linter#RemoveIgnored(a:buffer, l:filetype, l:linters)
                            
                                " Tell other sources that they can start checking the buffer now.
    2              0.000017     let g:ale_want_results_buffer = a:buffer
    2   0.000095   0.000056     silent doautocmd <nomodeline> User ALEWantResults
    2              0.000011     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    2              0.000016     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
    2              0.000001     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    2              0.000058     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    2   0.029450   0.000054     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 2 times
Total time:   0.059232
 Self time:   0.033050

count  total (s)   self (s)
    2              0.000010   let visible = tabpagebuflist()
                            
 2812              0.004944   for bufnr in range(1, bufnr('$') + 1)
 2810              0.003428     if buflisted(bufnr)
   72              0.001322       let file = expand('#'.bufnr.':p')
   72              0.000175       if !empty(file)
   72              0.000226         if index(visible, bufnr) != -1
    4   0.023983   0.000096           call gitgutter#process_buffer(bufnr, a:force)
   68              0.000069         elseif a:force
   68   0.002964   0.000669           call s:reset_tick(bufnr)
   72              0.000038         endif
   72              0.000029       endif
 2810              0.000990     endif
 2812              0.001250   endfor

FUNCTION  airline#async#vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:95
Called 24 times
Total time:   0.013797
 Self time:   0.001282

count  total (s)   self (s)
   24              0.000063   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
   24              0.000156   elseif has("nvim")
                                " nvim async
   24   0.013127   0.000612     noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
   24              0.000016   endif

FUNCTION  <SNR>117_has_fresh_changes()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:162
Called 1 time
Total time:   0.000030
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000029   0.000014   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:187
Called 84 times
Total time:   0.050264
 Self time:   0.003982

count  total (s)   self (s)
   84   0.005677   0.000864   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   84              0.000163   if empty(dir)
                                return ''
   84              0.000046   endif
   84   0.042316   0.000846   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:255
Called 8 times
Total time:   4.606605
 Self time:   0.139903

count  total (s)   self (s)
    8              0.000026     let bufnr = a:0 ? a:1 : ''
    8              0.000030     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
    8              0.000111     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    8              0.000022     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    8              0.000020     let airline_grouplist = []
    8              0.000167     let buffers_in_tabpage = sort(tabpagebuflist())
    8              0.000020     if exists("*uniq")
    8              0.000056       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    8              0.000005     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
   22              0.000050     for mode in reverse(mapped)
   14              0.000077       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    6              0.000022         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
 2934              0.007340         for kvp in items(dict)
 2928              0.004501           let mode_colors = kvp[1]
 2928              0.003706           let name = kvp[0]
 2928              0.004992           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    1              0.000004             let name = 'airline_c'.bufnr
 2928              0.001128           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
 2928              0.010321           if name =~# 'airline_c\d\+'
 2851              0.012972             let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
 2851              0.006179             if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
 2808              0.001719               continue
   43              0.000022             endif
   77              0.000465           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
   24              0.000031             continue
   96              0.000054           endif
   96   0.002250   0.001089           if s:group_not_done(airline_grouplist, name.suffix)
   96   0.056317   0.001094             call airline#highlighter#exec(name.suffix, mode_colors)
   96              0.000063           endif
                            
   96              0.000287           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
   96              0.000061           endif
                            
  288              0.000716           for accent in keys(s:accents)
  192              0.000575             if !has_key(p.accents, accent)
                                          continue
  192              0.000095             endif
  192              0.000861             let colors = copy(mode_colors)
  192              0.000566             if p.accents[accent][0] != ''
   96              0.000264               let colors[0] = p.accents[accent][0]
  192              0.000109             endif
  192              0.000354             if p.accents[accent][2] != ''
   96              0.000195               let colors[2] = p.accents[accent][2]
  192              0.000090             endif
  192              0.000394             if len(colors) >= 5
  192              0.000713               let colors[4] = get(p.accents[accent], 4, '')
                                        else
                                          call add(colors, get(p.accents[accent], 4, ''))
  192              0.000103             endif
  192   0.004307   0.002276             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  192   0.105104   0.002248               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  192              0.000128             endif
  288              0.000244           endfor
  102              0.000076         endfor
                            
    6              0.000015         if empty(s:separators)
                                      " nothing to be done
                                      continue
    6              0.000002         endif
                                    " TODO: optimize this
 2880              0.009530         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
 2874   4.351322   0.045891           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
 2880              0.003011         endfor
   14              0.000007       endif
   22              0.000037     endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:32
Called 72 times
Total time:   0.000525
 Self time:   0.000525

count  total (s)   self (s)
   72              0.000307   if empty(s:client) || s:client['running'] == 0
                                return 0
   72              0.000038   endif
   72              0.000060   return 1

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 17 times
Total time:   0.000385
 Self time:   0.000342

count  total (s)   self (s)
   17              0.000259   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   13              0.000017     return a:arg
    4   0.000065   0.000021   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    4              0.000002   else
    4              0.000011     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:136
Called 91 times
Total time:   0.004734
 Self time:   0.004734

count  total (s)   self (s)
   91              0.000914   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   91              0.003700   return match(a:name, pat) > -1

FUNCTION  tagbar#currenttag()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:3830
Called 11 times
Total time:   0.001130
 Self time:   0.000771

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   11              0.000035     let s:statusline_in_use = 1
                            
   11              0.000017     if a:0 >= 1
                                    " also test for non-zero value for backwards compatibility
   11              0.000102         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   11              0.000035         let fullpath  = a:1 =~# 'f'
   11              0.000026         let prototype = a:1 =~# 'p'
   11              0.000014         if a:0 >= 2
   11              0.000021             let search_method = a:2
                                    else
                                        let search_method = 'nearest-stl'
   11              0.000006         endif
                                else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                    let search_method = 'nearest-stl'
   11              0.000006     endif
                            
   11   0.000398   0.000103     if !s:Init(1)
                                    return a:default
   11              0.000005     endif
                            
   11   0.000164   0.000102     let tag = s:GetNearbyTag(search_method, 1)
                            
   11              0.000022     if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
   11              0.000015     else
   11              0.000015         return a:default
                                endif

FUNCTION  <SNR>213_on_exit_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 4 times
Total time:   0.003452
 Self time:   0.000064

count  total (s)   self (s)
    4              0.000005   if !a:exit_code
    4   0.003443   0.000054     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    4              0.000002   endif

FUNCTION  ale#util#FunctionArgCount()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:368
Called 2 times
Total time:   0.000797
 Self time:   0.000111

count  total (s)   self (s)
    2   0.000066   0.000033     let l:Function = ale#util#GetFunction(a:function)
    2   0.000685   0.000033     let l:count = s:LoadArgCount(l:Function)
                            
                                " If we failed to get the count, forcibly load the autoload file, if the
                                " function is an autoload function. autoload functions aren't normally
                                " defined until they are called.
    2              0.000004     if l:count == 0
                                    let l:function_name = matchlist(string(l:Function), 'function([''"]\(.\+\)[''"])')[1]
                            
                                    if l:function_name =~# '#'
                                        execute 'runtime autoload/' . join(split(l:function_name, '#')[:-2], '/') . '.vim'
                                        let l:count = s:LoadArgCount(l:Function)
                                    endif
    2              0.000001     endif
                            
    2              0.000003     return l:count

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:290
Called 18 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
   18              0.000068   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   18              0.000011   endif

FUNCTION  <SNR>233_HandleOnlyWindow()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:3430
Called 1 time
Total time:   0.000185
 Self time:   0.000173

count  total (s)   self (s)
    1   0.000181   0.000169     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    1              0.000002     if tagbarwinnr == -1
    1              0.000001         return
                                endif
                            
                                let vim_quitting = s:vim_quitting
                                let s:vim_quitting = 0
                            
                                if vim_quitting && !s:HasOpenFileWindows()
                                    call tagbar#debug#log('Closing Tagbar window due to QuitPre event')
                                    if winnr('$') >= 1
                                        call s:goto_win(tagbarwinnr, 1)
                                    endif
                            
                                    " Before quitting Vim, delete the tagbar buffer so that the '0 mark is
                                    " correctly set to the previous buffer.
                                    if tabpagenr('$') == 1
                                        noautocmd keepalt bdelete
                                    endif
                            
                                    try
                                        try
                                            quit
                                        catch /.*/ " This can be E173 and maybe others
                                            call s:OpenWindow('')
                                            echoerr v:exception
                                        endtry
                                    catch /.*/
                                        echohl ErrorMsg
                                        echo v:exception
                                        echohl None
                                    endtry
                                endif

FUNCTION  coc#util#check_refresh()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:62
Called 1 time
Total time:   0.000033
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000004   if !bufloaded(a:bufnr)
                                return 0
    1              0.000001   endif
    1              0.000004   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
    1              0.000001   endif
    1              0.000003   if get(g: , 'EasyMotion_loaded', 0)
    1   0.000016   0.000012     return EasyMotion#is_active() != 1
                              endif
                              return 1

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 4 times
Total time:   0.000626
 Self time:   0.000465

count  total (s)   self (s)
    4              0.000009   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    4              0.000025     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    4   0.000073   0.000033     let modified_lines = s:handle_double_hunk(a:modified_lines)
    4   0.000457   0.000335     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    4              0.000009     if exists('*sign_placelist')
    4              0.000042       call sign_placelist(signs)
    4              0.000003       return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:163
Called 2 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000040   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    2              0.000005   endif

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 84 times
Total time:   0.027309
 Self time:   0.013430

count  total (s)   self (s)
   84              0.000413   if !get(w:, 'airline_active', 0)
                                return ''
   84              0.000048   endif
                              " Cache values, so that it isn't called too often
   84   0.003233   0.002194   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   84              0.000046   endif
   84   0.009848   0.000883   let hunks = airline#extensions#hunks#get_raw_hunks()
   84              0.000129   let string = ''
   84   0.001415   0.000898   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   84              0.000186   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
  316              0.000686     for i in [0, 1, 2]
  237   0.004529   0.002189       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  237              0.001458         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  237              0.000161       endif
  316              0.000281     endfor
   84              0.000055   endif
   84   0.001344   0.001087   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
   84              0.000049   endif
                            
   84              0.000203   let b:airline_hunks = string
   84              0.000210   let b:airline_changenr = b:changedtick
   84   0.001356   0.000593   let s:airline_winwidth = airline#util#winwidth()
   84              0.000102   return string

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:231
Called 6 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
    6              0.000011     let l:min = 0
    6              0.000019     let l:max = len(a:loclist) - 1
                            
   11              0.000014     while 1
   11              0.000017         if l:max < l:min
    3              0.000003             return -1
    8              0.000004         endif
                            
    8              0.000023         let l:mid = (l:min + l:max) / 2
    8              0.000021         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
    8              0.000015         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
    8              0.000013         elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
    8              0.000017         elseif l:item.lnum < a:line
    4              0.000006             let l:min = l:mid + 1
    4              0.000006         elseif l:item.lnum > a:line
    1              0.000001             let l:max = l:mid - 1
    3              0.000002         else
                                        " This part is a small sequential search.
    3              0.000005             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    3              0.000017             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
    3              0.000003             endwhile
                            
                                        " Find the last problem on or before this column.
    7              0.000046             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
    4              0.000007                 let l:index += 1
    7              0.000005             endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    3              0.000009             let l:item_column = a:loclist[l:index].col
                            
    3              0.000015             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
    3              0.000006             endwhile
                            
    3              0.000004             return l:index
    5              0.000002         endif
    5              0.000004     endwhile

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:330
Called 84 times
Total time:   0.002619
 Self time:   0.002619

count  total (s)   self (s)
   84              0.000204   if empty(a:dir)
                                return ''
   84              0.000053   endif
   84              0.000381   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
   84              0.000042   endif
   84              0.000219   return s:commondirs[a:dir]

FUNCTION  ale#fix#InitBufferData()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim:330
Called 1 time
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
                                " The 'done' flag tells the function for applying changes when fixing
                                " is complete.
    1              0.000180     let g:ale_fix_buffer_data[a:buffer] = {   'lines_before': getbufline(a:buffer, 1, '$'),   'done': 0,   'should_save': a:fixing_flag is# 'save_file',   'ignore_file_changed_errors': a:fixing_flag is# '!',   'temporary_directory_list': [],}

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 91 times
Total time:   0.007014
 Self time:   0.002280

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   91   0.005912   0.001179   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   91              0.000068   endif
   91              0.000302   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   91              0.000056   else
   91              0.000213     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:581
Called 84 times
Total time:   0.041470
 Self time:   0.005987

count  total (s)   self (s)
   84              0.000354   let dir = a:0 > 1 ? a:2 : s:Dir()
   84              0.000133   if empty(dir)
                                return ''
   84              0.000044   endif
   84   0.036291   0.000808   let file = fugitive#Find('.git/HEAD', dir)
   84              0.001300   let ftime = getftime(file)
   84              0.000156   if ftime == -1
                                return ''
   84              0.000638   elseif ftime != get(s:head_cache, dir, [-1])[0]
    3              0.000085     let s:head_cache[dir] = [ftime, readfile(file)[0]]
   84              0.000048   endif
   84              0.000258   let head = s:head_cache[dir][1]
   84              0.000492   if head =~# '^ref: '
   84              0.001092     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>59_SyncAutocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:252
Called 1 time
Total time:   0.002252
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000006   if !g:coc_workspace_initialized
                                return
    1              0.000001   endif
    1              0.000002   if g:coc_service_initialized
    1   0.002221   0.000020     call coc#rpc#request('CocAutocmd', a:000)
                              else
                                call coc#rpc#notify('CocAutocmd', a:000)
    1              0.000001   endif

FUNCTION  <SNR>106_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:34
Called 1 time
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    1              0.000030   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000010   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    1              0.000001   else
    1              0.000002     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000027   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000025   let indent_spc  = search(head_spc, 'nw')
    1              0.000003   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    1              0.000001   else
    1              0.000001     return ''
                              endif

FUNCTION  ale#cursor#TruncatedEcho()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:13
Called 3 times
Total time:   0.000797
 Self time:   0.000772

count  total (s)   self (s)
    3              0.000010     let l:message = a:original_message
                                " Change tabs to spaces.
    3              0.000014     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    3              0.000010     let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    3              0.000011     let l:shortmess_options = &l:shortmess
                            
    3              0.000003     try
    3              0.000017         let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
    3   0.000036   0.000030         silent! setlocal shortmess+=T
                            
    3              0.000003         try
    3              0.000549             exec "norm! :echomsg l:message\n"
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    catch /E481/
                                        " Do nothing if running from a visual selection.
    3              0.000003         endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    3              0.000014         if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
    3              0.000002         endif
    3              0.000004     finally
    3   0.000037   0.000018         let &l:shortmess = l:shortmess_options
    3              0.000004     endtry

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:37
Called 30 times
Total time:   0.006764
 Self time:   0.006764

count  total (s)   self (s)
   30              0.000676     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   30              0.000205     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
   30              0.005513     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
   30              0.000104     if !empty(l:relative_path)
    6              0.000065         return fnamemodify(l:relative_path, ':p')
   24              0.000021     endif
                            
   24              0.000028     return ''

FUNCTION  <SNR>248_WinFindBuf()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:80
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000020     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 96 times
Total time:   0.133135
 Self time:   0.011113

count  total (s)   self (s)
   96              0.000329   if a:group1 == a:group2
                                return 0
   96              0.000060   endif
   96   0.062717   0.001159   let color1 = airline#highlighter#get_highlight(a:group1)
   96   0.061725   0.001261   let color2 = airline#highlighter#get_highlight(a:group2)
   96              0.008027   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  <SNR>232_valid_dir()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:50
Called 48 times
Total time:   0.000674
 Self time:   0.000674

count  total (s)   self (s)
   48              0.000380   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
   48              0.000037   endif
   48              0.000071   return a:dir

FUNCTION  ale#handlers#xo#GetType()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/xo.vim:35
Called 2 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    2              0.000019     let l:filetype = getbufvar(a:buffer, '&filetype')
    2              0.000005     let l:type = 'javascript'
                            
    2              0.000035     if l:filetype =~# 'typescript'
    2              0.000006         let l:type = 'typescript'
    2              0.000002     endif
                            
    2              0.000004     return l:type

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:679
Called 2 times
Total time:   0.029396
 Self time:   0.000387

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    2   0.000067   0.000032     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
    2   0.029321   0.000345     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:484
Called 6 times
Total time:   0.000774
 Self time:   0.000221

count  total (s)   self (s)
    6              0.000038     let l:info = get(g:ale_buffer_info, a:buffer, {})
    6              0.000027     let l:loclist = get(l:info, 'loclist', [])
    6              0.000025     let l:pos = getpos('.')
    6   0.000630   0.000077     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    6              0.000024     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    6              0.000017     return [l:info, l:loc]

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 90 times
Total time:   0.001962
 Self time:   0.001962

count  total (s)   self (s)
   90              0.000207   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   90              0.000397   let ggvars = getbufvar(buffer, 'gitgutter')
   90              0.000235   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
   90              0.000063   endif
   90              0.000335   let ggvars[a:varname] = a:val

FUNCTION  airline#extensions#fzf#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:37
Called 36 times
Total time:   0.000511
 Self time:   0.000511

count  total (s)   self (s)
   36              0.000166   if getbufvar(a:2.bufnr, '&filetype') ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
   36              0.000023   endif

FUNCTION  ale#command#InitData()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:22
Called 7 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    7              0.000040     if !has_key(s:buffer_data, a:buffer)
    1              0.000008         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
    7              0.000005     endif

FUNCTION  ale#highlight#CreatePositions()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:48
Called 10 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
   10              0.000022     if a:line >= a:end_line
                                    " For single lines, just return the one position.
   10              0.000054         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  <SNR>223_RemoveProblemsForDisabledLinters()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:477
Called 2 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    2              0.000006     let l:name_map = {}
                            
   12              0.000020     for l:linter in a:linters
   10              0.000034         let l:name_map[l:linter.name] = 1
   12              0.000009     endfor
                            
    2              0.000049     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  ale#statusline#Update()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:21
Called 2 times
Total time:   0.000240
 Self time:   0.000219

count  total (s)   self (s)
    2              0.000012     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
    2              0.000001     endif
                            
    2              0.000014     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    2   0.000043   0.000022     let l:count = s:CreateCountDict()
    2              0.000008     let l:count.total = len(l:loclist)
                            
                                " Allows easy access to the first instance of each problem type.
    2              0.000007     let l:first_problems = {}
                            
    2              0.000004     for l:entry in l:loclist
                                    if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                            
                                            if l:count.style_warning == 1
                                                let l:first_problems.style_warning = l:entry
                                            endif
                                        else
                                            let l:count.warning += 1
                            
                                            if l:count.warning == 1
                                                let l:first_problems.warning = l:entry
                                            endif
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                            
                                        if l:count.info == 1
                                            let l:first_problems.info = l:entry
                                        endif
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                            
                                        if l:count.style_error == 1
                                            let l:first_problems.style_error = l:entry
                                        endif
                                    else
                                        let l:count.error += 1
                            
                                        if l:count.error == 1
                                            let l:first_problems.error = l:entry
                                        endif
                                    endif
    2              0.000004     endfor
                            
                                " Set keys for backwards compatibility.
    2              0.000009     let l:count[0] = l:count.error + l:count.style_error
    2              0.000007     let l:count[1] = l:count.total - l:count[0]
                            
    2              0.000017     let g:ale_buffer_info[a:buffer].count = l:count
    2              0.000010     let g:ale_buffer_info[a:buffer].first_problems = l:first_problems

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 4 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    4              0.000032   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>103_ale_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:130
Called 4 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    4              0.000027   if !exists('#airline')
                                " airline disabled
                                return
    4              0.000003   endif
    4              0.000014   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    4              0.000002   endif

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 89 times
Total time:   0.002749
 Self time:   0.001319

count  total (s)   self (s)
   89   0.002698   0.001269   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>63_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:377
Called 89 times
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
   89              0.000171     return a:path

FUNCTION  <SNR>231_FileIgnoreCase()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:131
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000007   return (exists('+fileignorecase') && &fileignorecase) || (a:for_completion && exists('+wildignorecase') && &wildignorecase)

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:5
Called 10 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   10              0.000066     return call('mode', a:000)

FUNCTION  <SNR>250_CreateCountDict()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:5
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    2              0.000017     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  ale#other_source#ShowResults()
    Defined: ~/.vim/plugged/ale/autoload/ale/other_source.vim:12
Called 1 time
Total time:   0.002487
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000031   0.000014     call ale#engine#InitBufferInfo(a:buffer)
    1              0.000004     let l:info = g:ale_buffer_info[a:buffer]
                            
                                " Remove this linter name from the active list.
    1              0.000004     let l:list = l:info.active_other_sources_list
    1              0.000006     call filter(l:list, 'v:val isnot# a:linter_name')
                            
    1   0.002438   0.000019     call ale#engine#HandleLoclist(a:linter_name, a:buffer, a:loclist, 1)

FUNCTION  <SNR>232_nvim_output_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:232
Called 9 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
    9              0.000064     if a:event == 'stdout' || a:event == 'stderr'
    9              0.000095       let self.buf .=  join(a:data)
    9              0.000011     endif

FUNCTION  <SNR>110_search_term()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:20
Called 50 times
Total time:   0.004660
 Self time:   0.000744

count  total (s)   self (s)
                              " shorten for all width smaller than 300 (this is just a guess)
                              " this uses a non-breaking space, because it looks like
                              " a leading space is stripped :/
   50   0.004557   0.000640   return "\ua0" .  '/' . airline#util#shorten(getreg('/'), 300, 8)

FUNCTION  ale#list#SetLists()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:189
Called 2 times
Total time:   0.000713
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000014     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
    2   0.000680   0.000031         call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
                                    call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    2              0.000001     endif

FUNCTION  <SNR>64_on_bufenter()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:220
Called 1 time
Total time:   0.000674
 Self time:   0.000061

count  total (s)   self (s)
    1   0.000055   0.000010   call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
    1              0.000009   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
    1              0.000001   endif
                            
    1              0.000004   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    1              0.000001   else
    1   0.000587   0.000020     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    1              0.000001   endif

FUNCTION  <SNR>98_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 9248 times
Total time:   0.070217
 Self time:   0.070217

count  total (s)   self (s)
 9248              0.066202     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 84 times
Total time:   0.001298
 Self time:   0.001298

count  total (s)   self (s)
   84              0.001235   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>232_untracked_output()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:12
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000017   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
    2              0.000002   else
    2              0.000009     let a:dict.cfg.untracked[a:dict.file] = ''
    2              0.000001   endif

FUNCTION  <SNR>17_get_shiftwidth()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/polyglot/init.vim:2777
Called 1 time
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    1              0.000002     let shiftwidth = 0
    1              0.000001     let max_count = 0
    1              0.000003     let final_counts = {}
    6              0.000018     for [indent, indent_count] in items(a:indents)
    5              0.000011       let indent_count = indent_count * 1.5
   30              0.000044       for [indent2, indent2_count] in items(a:indents)
   25              0.000036         if indent2 > indent && indent2 % indent == 0
    5              0.000007           let indent_count = indent_count + indent2_count
   25              0.000009         endif
   30              0.000012       endfor
    5              0.000009       let final_counts[indent] = indent_count
    6              0.000003     endfor
    6              0.000010     for [indent, final_count] in items(final_counts)
    5              0.000006       if final_count > max_count
    1              0.000001         let shiftwidth = indent
    1              0.000001         let max_count = final_count
    5              0.000002       endif
    6              0.000002     endfor
    1              0.000002     return shiftwidth

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:259
Called 2 times
Total time:   0.000696
 Self time:   0.000408

count  total (s)   self (s)
    2   0.000163   0.000037     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
    2              0.000005     if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
    2              0.000001     endif
                            
    2              0.000005     let l:bufnr_map = {}
    2              0.000004     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    2   0.000148   0.000024     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    2              0.000007     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
                                    let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
                                    if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
                                    if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
                                    endif
                            
                                    let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
                                    if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
                                    endif
                            
                                    if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
                                    if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
                                    if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
                                    if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
                                    if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
                                    if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
                                    call add(l:new_loclist, l:item)
    2              0.000010     endfor
                            
    2   0.000069   0.000031     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    2              0.000005     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    2              0.000001     endif
                            
    2              0.000003     return l:new_loclist

FUNCTION  <SNR>225_HandleESLintOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/eslint.vim:243
Called 1 time
Total time:   0.000282
 Self time:   0.000122

count  total (s)   self (s)
    1   0.000117   0.000009     if s:CheckForBadConfig(a:buffer, a:lines)
                                    return [{   'lnum': 1,   'text': 'eslint configuration error (type :ALEDetail for more information)',   'detail': join(a:lines, "\n"),}]
    1              0.000000     endif
                            
    1              0.000002     if a:lines == ['Could not connect']
                                    return [{   'lnum': 1,   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',}]
    1              0.000000     endif
                            
    1              0.000001     if a:type is# 'json'
    1   0.000055   0.000013         let l:output = s:parseJSON(a:buffer, a:lines)
                                else
                                    let l:output = s:parseLines(a:buffer, a:lines)
    1              0.000000     endif
                            
    1              0.000048     call filter(l:output, {idx, obj -> s:FilterResult(a:buffer, obj)})
                            
    1              0.000017     if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
    1   0.000026   0.000016         call s:AddHintsForTypeScriptParsingErrors(l:output)
    1              0.000001     endif
                            
    1              0.000002     return l:output

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:188
Called 79 times
Total time:   0.003401
 Self time:   0.000821

count  total (s)   self (s)
   79   0.003339   0.000759   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  <SNR>103_airline_ale_count()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:11
Called 140 times
Total time:   0.000535
 Self time:   0.000535

count  total (s)   self (s)
  140              0.000462   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 4 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    4              0.000017   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    4              0.000003   endif

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:184
Called 2 times
Total time:   0.004073
 Self time:   0.000251

count  total (s)   self (s)
    2   0.000049   0.000020     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    2              0.000003     if g:ale_set_signs
    2   0.001019   0.000028         call ale#sign#SetSigns(a:buffer, a:loclist)
    2              0.000001     endif
                            
    2              0.000005     if g:ale_set_quickfix || g:ale_set_loclist
    2   0.000740   0.000027         call ale#list#SetLists(a:buffer, a:loclist)
    2              0.000001     endif
                            
    2              0.000007     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
    2   0.000270   0.000029         call ale#statusline#Update(a:buffer, a:loclist)
    2              0.000002     endif
                            
    2              0.000004     if g:ale_set_highlights
    2   0.001151   0.000030         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    2              0.000001     endif
                            
    2              0.000003     if l:linting_is_done
    1              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.000569   0.000009             call ale#cursor#EchoCursorWarning()
    1              0.000000         endif
                            
    1              0.000001         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    1              0.000000         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000004         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000004         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.000152   0.000014         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000040   0.000010         silent doautocmd <nomodeline> User ALELintPost
    2              0.000001     endif

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:173
Called 4 times
Total time:   0.003388
 Self time:   0.000331

count  total (s)   self (s)
    4   0.000142   0.000025   call gitgutter#debug#log(a:diff)
                            
    4              0.000008   if !bufexists(a:bufnr)
                                return
    4              0.000001   endif
                            
    4   0.000738   0.000055   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    4   0.001573   0.000050   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    4              0.000009   let signs_count = len(modified_lines)
    4              0.000010   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    4              0.000002   else
    4              0.000009     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    4   0.000672   0.000046       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    4              0.000002     endif
    4              0.000002   endif
                            
    4   0.000150   0.000043   call s:save_last_seen_change(a:bufnr)
    4              0.000015   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    4              0.000002   endif

FUNCTION  <SNR>258_AddSubCallbacks()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim:238
Called 2 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000010     if type(a:callbacks) is v:t_string
                                    call add(a:full_list, a:callbacks)
    2              0.000006     elseif type(a:callbacks) is v:t_list
    1              0.000005         call extend(a:full_list, a:callbacks)
    1              0.000001     else
    1              0.000001         return 0
    1              0.000001     endif
                            
    1              0.000001     return 1

FUNCTION  ale#job#Stop()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:346
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000004     if !has_key(s:job_map, a:job_id)
                                    return
    1              0.000001     endif
                            
    1              0.000006     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
    1              0.000023         silent! call jobstop(a:job_id)
                                else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
    1              0.000001     endif

FUNCTION  <SNR>250_BufferCacheExists()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:88
Called 306 times
Total time:   0.003125
 Self time:   0.003125

count  total (s)   self (s)
  306              0.001987     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return 0
  306              0.000178     endif
                            
  306              0.000260     return 1

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:63
Called 6 times
Total time:   0.003434
 Self time:   0.000626

count  total (s)   self (s)
    6              0.000051     let l:buffer = bufnr('')
                            
    6              0.000018     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    6              0.000005     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    6              0.000025     if mode(1) isnot# 'n'
                                    return
    6              0.000003     endif
                            
    6   0.000989   0.000068     if ale#ShouldDoNothing(l:buffer)
                                    return
    6              0.000002     endif
                            
    6   0.000852   0.000078     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    6              0.000008     if g:ale_echo_cursor
    6              0.000013         if !empty(l:loc)
    3   0.000081   0.000033             let l:format = ale#Var(l:buffer, 'echo_msg_format')
    3   0.000302   0.000033             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    3   0.000833   0.000036             call ale#cursor#TruncatedEcho(l:msg)
    3              0.000008             let l:info.echoed = 1
    3              0.000007         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
    3              0.000044             execute 'echo'
    3              0.000010             let l:info.echoed = 0
    6              0.000004         endif
    6              0.000003     endif
                            
    6              0.000009     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
    6              0.000003     endif

FUNCTION  <SNR>98_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 3212 times
Total time:   0.077893
 Self time:   0.077893

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
 3212              0.012059     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
 3212              0.001674     endif
 3212              0.010861     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                  return a:colors
 3212              0.001373     endif
                            
 3212              0.010109     for val in a:colors
 3212              0.009729       if !empty(val) && val !=# 'NONE'
 3212              0.003736         return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>103_new_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:40
Called 140 times
Total time:   0.014683
 Self time:   0.004577

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
  140              0.000210   if a:cnt == 0
   22              0.000020     return ''
  118              0.000064   endif
  118              0.000428   let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
  118   0.008561   0.001104   let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
  118              0.000211   if empty(l:result)
                                " If there are no errors then try and check for style errors.
   48   0.003150   0.000501     let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
  118              0.000069   endif
                            
  118              0.000170   if empty(l:result)
   48              0.000046       return ''
   70              0.000031   endif
                            
   70              0.000280   let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
   70              0.000237   let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
   70              0.000271   return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  <SNR>231_ExpireStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3312
Called 3 times
Total time:   0.000194
 Self time:   0.000088

count  total (s)   self (s)
    3              0.000006   if a:bufnr is# -2
    2              0.000013     let s:head_cache = {}
    2              0.000012     let s:last_time = reltime()
    2              0.000002     return ''
    1              0.000000   endif
    1   0.000077   0.000010   let dir = s:Dir(a:bufnr)
    1              0.000002   if len(dir)
    1   0.000059   0.000019     let s:last_times[s:cpath(dir)] = reltime()
    1              0.000003     if has_key(s:head_cache, dir)
    1              0.000010       call remove(s:head_cache, dir)
    1              0.000001     endif
    1              0.000000   endif
    1              0.000001   return ''

FUNCTION  ale#statusline#FirstProblem()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:127
Called 166 times
Total time:   0.010106
 Self time:   0.003465

count  total (s)   self (s)
  166   0.008219   0.001579     let l:first_problems = s:GetFirstProblems(a:buffer)
                            
  166              0.000684     if !empty(l:first_problems) && has_key(l:first_problems, a:type)
   70              0.000561         return copy(l:first_problems[a:type])
   96              0.000052     endif
                            
   96              0.000134     return {}

FUNCTION  ale#fix#ApplyQueuedFixes()
    Defined: ~/.vim/plugged/ale/autoload/ale/fix.vim:9
Called 2 times
Total time:   0.015570
 Self time:   0.000156

count  total (s)   self (s)
    2              0.000012     let l:data = get(g:ale_fix_buffer_data, a:buffer, {'done': 0})
                            
    2   0.000019   0.000014     if !l:data.done || (!ale#util#HasBuflineApi() && a:buffer isnot bufnr(''))
    1              0.000001         return
    1              0.000000     endif
                            
    1              0.000004     call remove(g:ale_fix_buffer_data, a:buffer)
                            
    1              0.000001     try
    1              0.000001         if l:data.changes_made
                                        let l:new_lines = ale#util#SetBufferContents(a:buffer, l:data.output)
                            
                                        if l:data.should_save
                                            if a:buffer is bufnr('')
                                                if empty(&buftype)
                                                    noautocmd :w!
                                                else
                                                    set nomodified
                                                endif
                                            else
                                                call writefile(l:new_lines, expand('#' . a:buffer . ':p')) " no-custom-checks
                                                call setbufvar(a:buffer, '&modified', 0)
                                            endif
                                        endif
    1              0.000000         endif
                                catch /E21/
                                    " If we cannot modify the buffer now, try again later.
                                    let g:ale_fix_buffer_data[a:buffer] = l:data
                            
                                    return
    1              0.000001     endtry
                            
    1              0.000001     if l:data.should_save
    1   0.000038   0.000012         let l:should_lint = ale#Var(a:buffer, 'fix_on_save')   && ale#Var(a:buffer, 'lint_on_save')
                                else
                                    let l:should_lint = l:data.changes_made
    1              0.000000     endif
                            
    1   0.000023   0.000013     silent doautocmd <nomodeline> User ALEFixPost
                            
                                " If ALE linting is enabled, check for problems with the file again after
                                " fixing problems.
    1   0.000019   0.000010     if g:ale_enabled&& l:should_lint&& !ale#events#QuitRecently(a:buffer)
    1   0.015397   0.000033         call ale#Queue(0, l:data.should_save ? 'lint_file' : '')
    1              0.000001     endif

FUNCTION  <SNR>101_config_fugitive_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:99
Called 84 times
Total time:   0.053977
 Self time:   0.002766

count  total (s)   self (s)
   84   0.051640   0.001376   let s:vcs_config['git'].branch = exists('*FugitiveHead') ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   84   0.001995   0.001048   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
   84              0.000048   endif

FUNCTION  ale#history#Get()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:8
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000018     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  267()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:22
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
                              " At this point this nvim instance might already have launched
                              " a new provider instance. Don't drop ownership in this case.
    2              0.000007   if self.owner == a:jobid
    2              0.000005     let self.owner = 0
    2              0.000001   endif
    2              0.000002   if a:data != 0
                                echohl WarningMsg
                                echomsg 'clipboard: error invoking '.get(self.argv, 0, '?').': '.join(self.stderr)
                                echohl None
    2              0.000001   endif

FUNCTION  269()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:171
Called 3 times
Total time:   0.018009
 Self time:   0.013546

count  total (s)   self (s)
    3              0.000016   if a:reg == '"'
    1              0.000005     call s:clipboard.set(a:lines,a:regtype,'+')
    1              0.000007     if s:copy['*'] != s:copy['+']
    1              0.000012       call s:clipboard.set(a:lines,a:regtype,'*')
    1              0.000001     end
    1              0.000002     return 0
    2              0.000001   end
                            
    2              0.000010   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
    2              0.000001   end
                            
    2              0.000003   if s:cache_enabled == 0
                                call s:try_cmd(s:copy[a:reg], a:lines)
                                "Cache it anyway we can compare it later to get regtype of the yank
                                let s:selections[a:reg] = copy(s:selection)
                                let s:selections[a:reg].data = [a:lines, a:regtype]
                                return 0
    2              0.000001   end
                            
    2              0.000006   if s:selections[a:reg].owner > 0
    2              0.000005     let prev_job = s:selections[a:reg].owner
    2              0.000001   end
    2              0.000015   let s:selections[a:reg] = copy(s:selection)
    2              0.000012   let selection = s:selections[a:reg]
    2              0.000010   let selection.data = [a:lines, a:regtype]
    2              0.000004   let selection.argv = s:copy[a:reg]
    2              0.000003   let selection.detach = s:cache_enabled
    2              0.000003   let selection.cwd = "/"
    2              0.008649   let jobid = jobstart(selection.argv, selection)
    2              0.000014   if jobid > 0
    2              0.000051     call jobsend(jobid, a:lines)
    2              0.000007     call jobclose(jobid, 'stdin')
                                " xclip does not close stdout when receiving input via stdin
    2              0.000008     if selection.argv[0] ==# 'xclip'
    2              0.000004       call jobclose(jobid, 'stdout')
    2              0.000003     endif
    2              0.000008     let selection.owner = jobid
    2              0.000003     let ret = 1
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                let ret = 1
    2              0.000001   endif
                            
                              " The previous provider instance should exit when the new one takes
                              " ownership, but kill it to be sure we don't fill up the job table.
    2              0.000006   if exists('prev_job')
    2              0.000047     call timer_start(1000, {... -> jobwait([prev_job], 0)[0] == -1 && jobstop(prev_job)})
    2              0.000001   endif
                            
    2              0.000006   return ret

FUNCTION  <SNR>232_nvim_untracked_job_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:238
Called 2 times
Total time:   0.000096
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000006     if a:event == 'exit'
    2   0.000070   0.000028       call s:untracked_output(self, self.buf)
    2              0.000007       if has_key(s:untracked_jobs, self.file)
    2              0.000008         call remove(s:untracked_jobs, self.file)
    2              0.000001       endif
    2              0.000001     endif

FUNCTION  <SNR>114_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 224 times
Total time:   0.011104
 Self time:   0.008780

count  total (s)   self (s)
  224              0.000863   if has_key(s:section_truncate_width, a:key)
  140   0.003052   0.001459     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
   76              0.000362       return ''
   64              0.000035     endif
  148              0.000080   endif
  148              0.000383   let spc = g:airline_symbols.space
  148              0.000846   if !exists('g:airline_section_{a:key}')
                                return ''
  148              0.000078   endif
  148   0.002510   0.001779   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  148              0.001357   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  148              0.000653   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:158
Called 108 times
Total time:   0.001139
 Self time:   0.001139

count  total (s)   self (s)
  108              0.000557   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
  108              0.000069   endif
  108              0.000165   return s:has_lawrencium

FUNCTION  provider#clipboard#Call()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:230
Called 1 time
Total time:   0.009084
 Self time:   0.000053

count  total (s)   self (s)
    1              0.000007   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
    1              0.000001   endif
    1              0.000002   let s:here = v:true
    1              0.000001   try
    1   0.009061   0.000029     return call(s:clipboard[a:method],a:args,s:clipboard)
    1              0.000002   finally
    1              0.000004     let s:here = v:false
    1              0.000002   endtry

FUNCTION  <SNR>238_is_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:273
Called 10 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
   10              0.000019   return a:from_count == 0 && a:to_count > 0

FUNCTION  276()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 40 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
   40              0.000213   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>91_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 40 times
Total time:   0.002786
 Self time:   0.002786

count  total (s)   self (s)
   40              0.000139   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
   40              0.000045   endfor
                            
  160              0.000247   for matchw in g:airline_exclude_filenames
  120              0.001399     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
  120              0.000064     endif
  160              0.000109   endfor
                            
   40              0.000087   if g:airline_exclude_preview && &previewwindow
                                return 1
   40              0.000023   endif
                            
   40              0.000046   return 0

FUNCTION  278()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 176 times
Total time:   0.000996
 Self time:   0.000996

count  total (s)   self (s)
  176              0.000917   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>231_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:118
Called 84 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   84              0.000151     return a:path

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:774
Called 7 times
Total time:   0.000241
 Self time:   0.000117

count  total (s)   self (s)
    7   0.000194   0.000070   let id = coc#float#get_related(a:winid, 'scrollbar')
    7              0.000017   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
    7              0.000004   endif

FUNCTION  <SNR>249_matchaddpos()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:89
Called 10 times
Total time:   0.001368
 Self time:   0.000625

count  total (s)   self (s)
   10              0.000017     if s:has_nvim_highlight
   20              0.000040         for l:pos in a:pos_list
   10              0.000054             let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                            
   10              0.000037             if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
   10              0.000007             else
   10              0.000022                 let l:col_start = l:pos[1] - 1
   10              0.000031                 let l:col_end = l:col_start + get(l:pos, 2, 1)
   10              0.000005             endif
                            
   10   0.000877   0.000134             call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
   20              0.000020         endfor
                                else
                                    call matchaddpos(a:group, a:pos_list)
   10              0.000005     endif

FUNCTION  <SNR>233_TagbarBufName()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:3582
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000008     if !exists('t:tagbar_buf_name')
                                    let s:buffer_seqno += 1
                                    let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
    2              0.000001     endif
                            
    2              0.000003     return t:tagbar_buf_name

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:42
Called 84 times
Total time:   0.004937
 Self time:   0.000897

count  total (s)   self (s)
   84   0.004879   0.000839   return airline#extensions#nvimlsp#get('Error')

FUNCTION  ale#util#GetFunction()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:87
Called 10 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
   10              0.000048     if type(a:string_or_ref) is v:t_string
    3              0.000010         return function(a:string_or_ref)
    7              0.000005     endif
                            
    7              0.000012     return a:string_or_ref

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 84 times
Total time:   0.003901
 Self time:   0.003901

count  total (s)   self (s)
   84              0.000770   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   84              0.000416     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   84              0.000390     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   84              0.000384     let default = get(g:, 'airline#extensions#keymap#default', '')
   84              0.000146     if (label !=# '')
   84              0.000227       let label .= ' '
   84              0.000056     endif
   84              0.000175     let keymap = &keymap
   84              0.000238     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   84              0.000050     endif
   84              0.000672     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  283()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 40 times
Total time:   0.296702
 Self time:   0.039152

count  total (s)   self (s)
   40              0.000078   let side = 1
   40              0.000049   let line = ''
   40              0.000046   let i = 0
   40              0.000135   let length = len(self._sections)
   40              0.000050   let split = 0
   40              0.000105   let is_empty = 0
   40              0.000059   let prev_group = ''
                            
  256              0.000478   while i < length
  216              0.000661     let section = self._sections[i]
  216              0.000486     let group = section[0]
  216              0.000499     let contents = section[1]
  216              0.000397     let pgroup = prev_group
  216   0.016202   0.012661     let prev_group = airline#builder#get_prev_group(self._sections, i)
  216              0.000709     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
  216              0.000915     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
  216              0.000910     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
  216              0.000141     endif
  216              0.000238     if is_empty
                                  let prev_group = pgroup
  216              0.000115     endif
  216   0.004204   0.002293     let is_empty = s:section_is_empty(self, contents)
                            
  216              0.000206     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
  216              0.000120     endif
                            
  216              0.000321     if group == ''
                                  let line .= contents
  216              0.000285     elseif group == '|'
   40              0.000050       let side = 0
   40              0.000099       let line .= contents
   40              0.000047       let split = 1
  176              0.000104     else
  176              0.000288       if prev_group == ''
   40              0.000161         let line .= '%#'.group.'#'
  136              0.000147       elseif split
   40              0.000043         if !is_empty
   40   0.092318   0.000601           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   40              0.000032         endif
   40              0.000068         let split = 0
   96              0.000057       else
   96              0.000109         if !is_empty
   96   0.152189   0.001389           let line .= s:get_seperator(self, prev_group, group, side)
   96              0.000076         endif
  176              0.000142       endif
  176   0.012593   0.003011       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  216              0.000142     endif
                            
  216              0.000437     let i = i + 1
  256              0.000324   endwhile
                            
   40              0.000083   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   36              0.001155     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   40              0.000037   endif
   40              0.000077   return line

FUNCTION  ale#util#Tempname()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:300
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000004     let l:clear_tempdir = 0
                            
    2              0.000017     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    2              0.000001     endif
                            
    2              0.000002     try
    2              0.000007         let l:name = tempname() " no-custom-checks
    2              0.000003     finally
    2              0.000002         if l:clear_tempdir
                                        let $TMPDIR = ''
    2              0.000001         endif
    2              0.000002     endtry
                            
    2              0.000003     return l:name

FUNCTION  <SNR>101_display_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:122
Called 5 times
Total time:   0.000384
 Self time:   0.000249

count  total (s)   self (s)
                              " disable FocusGained autocommand, might cause loops because system() causes
                              " a refresh, which causes a system() command again #2029
    5   0.000085   0.000043   call airline#util#ignore_next_focusgain()
    5              0.000013   let name = b:buffer_vcs_config['git'].branch
    5              0.000005   try
    5   0.000159   0.000067     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
    5              0.000013     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
    5              0.000008     elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
    5              0.000002     endif
                              catch
    5              0.000005   endtry
    5              0.000006   return name

FUNCTION  <SNR>223_HandleExit()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:151
Called 1 time
Total time:   0.003206
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000006     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    1              0.000002     if empty(l:buffer_info)
                                    return
    1              0.000000     endif
                            
    1              0.000003     let l:linter = a:job_info.linter
    1              0.000002     let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
    1   0.000016   0.000010     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    1   0.000031   0.000007     if ale#util#InSandbox()
                                    return
    1              0.000000     endif
                            
    1              0.000009     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    1              0.000000     endif
                            
    1              0.000001     try
    1   0.000311   0.000014         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    1              0.000001     endtry
                            
    1   0.002813   0.000013     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  <SNR>213_on_stderr_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 4 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    4              0.000008   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    4              0.000002   endif

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 91 times
Total time:   0.003768
 Self time:   0.003768

count  total (s)   self (s)
   91              0.000421   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   91              0.000264   let bomb     = &bomb ? '[BOM]' : ''
   91              0.000661   let noeolf   = &eol ? '' : '[!EOL]'
   91              0.000936   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   91              0.000622   if expected is# &fenc.bomb.noeolf.ff
                                return ''
   91              0.000058   else
   91              0.000463     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 4 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    4              0.000010   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    4              0.000002   endif

FUNCTION  ale#linter#GetCwd()
    Defined: ~/.vim/plugged/ale/autoload/ale/linter.vim:432
Called 2 times
Total time:   0.001337
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000010     let l:Cwd = get(a:linter, 'cwd', v:null)
                            
    2   0.001324   0.000028     return type(l:Cwd) is v:t_func ? l:Cwd(a:buffer) : l:Cwd

FUNCTION  <SNR>231_Dir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:351
Called 1 time
Total time:   0.000066
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000066   0.000009   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:38
Called 84 times
Total time:   0.006428
 Self time:   0.000912

count  total (s)   self (s)
   84   0.006373   0.000857   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  <SNR>223_GetLintFileSlots()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:591
Called 2 times
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
    2              0.000009     let l:linter_slots = []
                            
   12              0.000021     for l:linter in a:linters
   10              0.000020         let l:LintFile = l:linter.lint_file
                            
   10              0.000026         if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
   10              0.000005         endif
                            
   10              0.000044         call add(l:linter_slots, [l:LintFile, l:linter])
   12              0.000009     endfor
                            
    2              0.000003     return l:linter_slots

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:64
Called 3 times
Total time:   0.030681
 Self time:   0.030681

count  total (s)   self (s)
    3              0.030677     let s:hl_groups = {}

FUNCTION  airline#extensions#ale#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:112
Called 84 times
Total time:   0.023319
 Self time:   0.001251

count  total (s)   self (s)
   84   0.023241   0.001173   return airline#extensions#ale#get('warning')

FUNCTION  <SNR>233_HandleBufWrite()
    Defined: ~/.vim/plugged/tagbar/autoload/tagbar.vim:3523
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000010     if index(s:delayed_update_files, a:fname) == -1
    1              0.000005         call add(s:delayed_update_files, a:fname)
    1              0.000001     endif

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:231
Called 4 times
Total time:   0.001454
 Self time:   0.000131

count  total (s)   self (s)
    4              0.000006   let modified_lines = []
   14              0.000016   for hunk in a:hunks
   10   0.001404   0.000081     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   14              0.000008   endfor
    4              0.000004   return modified_lines

FUNCTION  ale#fixers#generic#TrimWhitespace()
    Defined: ~/.vim/plugged/ale/autoload/ale/fixers/generic.vim:15
Called 1 time
Total time:   0.000971
 Self time:   0.000971

count  total (s)   self (s)
    1              0.000003     let l:index = 0
    1              0.000023     let l:lines_new = range(len(a:lines))
                            
  109              0.000097     for l:line in a:lines
  108              0.000628         let l:lines_new[l:index] = substitute(l:line, '\s\+$', '', 'g')
  108              0.000126         let l:index = l:index + 1
  109              0.000058     endfor
                            
    1              0.000002     return l:lines_new

FUNCTION  <SNR>213_on_stdout_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 6 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    6              0.000012   if empty(self.stdoutbuffer)
    4              0.000009     let self.stdoutbuffer = a:data
    2              0.000001   else
    2              0.000018     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    6              0.000003   endif

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 40 times
Total time:   0.001564
 Self time:   0.001564

count  total (s)   self (s)
   40              0.000438   let builder = copy(s:prototype)
   40              0.000107   let builder._context = a:context
   40              0.000086   let builder._sections = []
                            
   40              0.000783   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   40              0.000066   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   91   4.624055   0.015420  airline#check_mode()
    8   4.606605   0.139903  airline#highlighter#highlight()
 2922   4.408518   0.164290  <SNR>98_exec_separator()
 9248   3.951250   1.256624  airline#highlighter#get_highlight()
 5844   3.031052   0.073936  airline#themes#get_highlight()
36992   2.624410             <SNR>98_get_syn()
 3212   1.372320   0.311118  airline#highlighter#exec()
    4   0.346424   0.000490  airline#update_statusline()
   40   0.341461   0.003525  <SNR>93_invoke_funcrefs()
   40   0.296702   0.039152  283()
    3   0.280699   0.000120  <SNR>23_on_focus_gained()
    3   0.280507   0.003605  <SNR>23_airline_refresh()
    4   0.278524   0.002475  airline#update_statusline_inactive()
   96   0.150801   0.002369  <SNR>113_get_seperator()
   96   0.133135   0.011113  airline#builder#should_change_group()
   84   0.125714   0.004398  airline#extensions#branch#get_head()
   84   0.117917   0.003994  airline#extensions#branch#head()
    1   0.113325   0.000085  <SNR>67_TmuxAwareNavigate()
    1   0.113232   0.000037  <SNR>67_VimNavigate()
 3212   0.111197             <SNR>98_hl_group_exists()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
36992              2.624410  <SNR>98_get_syn()
 9248   3.951250   1.256624  airline#highlighter#get_highlight()
 3212   1.372320   0.311118  airline#highlighter#exec()
 2922   4.408518   0.164290  <SNR>98_exec_separator()
    8   4.606605   0.139903  airline#highlighter#highlight()
 3212              0.111197  <SNR>98_hl_group_exists()
 3212              0.077893  <SNR>98_CheckDefined()
 5844   3.031052   0.073936  airline#themes#get_highlight()
 9248              0.070217  <SNR>98_get_array()
   40   0.296702   0.039152  283()
    2   0.059232   0.033050  gitgutter#all()
    3              0.030681  airline#highlighter#reset_hlcache()
   84   0.035483   0.023302  fugitive#Find()
    4   0.019233   0.019059  gitgutter#async#execute()
   91   4.624055   0.015420  airline#check_mode()
 1279              0.014626  airline#util#winwidth()
  168   0.043171   0.014490  airline#extensions#ale#get()
    3   0.018009   0.013546  269()
   84   0.027309   0.013430  airline#extensions#hunks#get_hunks()
 1204   0.015017   0.013295  airline#util#wrap()

